{"ast":null,"code":"import { HttpHeaders, HttpParams } from '@angular/common/http';\n// Import the 'Injectable' decorator to make the class injectable as a service.\nimport { throwError } from 'rxjs';\n// Import Observable and throwError from RxJS to work with asynchronous operations.\nimport { catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\n// Import the catchError operator from RxJS to handle errors in observables.\n// Decorate the class as an injectable service.\nexport let ApiService = /*#__PURE__*/(() => {\n  class ApiService {\n    // Declare class properties to store tokens.\n    constructor(http) {\n      this.http = http;\n    }\n    // Constructor for the ApiService, injecting the HttpClient service for making HTTP requests.\n    formatErrors(httpResponse) {\n      // Define a private method to format and handle HTTP errors.\n      return throwError(httpResponse);\n      // Return an observable that emits the error response.\n    }\n\n    anonGet(path, params = new HttpParams()) {\n      // Create a method 'anonGet' to make an anonymous HTTP GET request.\n      return this.http.get(`${path}`, {\n        params\n      })\n      // Use HttpClient to make a GET request to the specified 'path' with optional parameters.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    get(path, params = new HttpParams()) {\n      // Create a method 'get' to make an HTTP GET request.\n      return this.http.get(`${path}`, {\n        params\n      })\n      // Use HttpClient to make a GET request to the specified 'path' with optional parameters.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    getFile(path, params = new HttpParams()) {\n      // Create a method 'getFile' to retrieve a file via HTTP GET.\n      return this.http.get(`${path}`, {\n        params,\n        responseType: 'arraybuffer'\n      })\n      // Use HttpClient to make a GET request to the specified 'path' with optional parameters and an 'arraybuffer' response type.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    delete(path, params = new HttpParams()) {\n      // Create a method 'delete' to make an HTTP DELETE request.\n      return this.http.delete(`${path}`, {\n        params\n      })\n      // Use HttpClient to make a DELETE request to the specified 'path' with optional parameters.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    post(path, body = {}) {\n      // Create a method 'post' to make an HTTP POST request with a JSON body.\n      const headers = new HttpHeaders().set('Content-Type', 'application/json');\n      // Define headers with a JSON content type.\n      return this.http.post(`${path}`, JSON.stringify(body), {\n        headers,\n        responseType: 'json'\n      })\n      // Use HttpClient to make a POST request to the specified 'path' with a JSON-serialized 'body', headers, and a JSON response type.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    postGetFile(path, body = {}) {\n      // Create a method 'postGetFile' to make an HTTP POST request and retrieve a file.\n      return this.http.post(`${path}`, JSON.stringify(body), {\n        responseType: 'arraybuffer'\n      })\n      // Use HttpClient to make a POST request to the specified 'path' with a JSON-serialized 'body' and an 'arraybuffer' response type.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    put(path, body = {}) {\n      // Create a method 'put' to make an HTTP PUT request with a JSON body.\n      const headers = new HttpHeaders().set('Content-Type', 'application/json');\n      // Define headers with a JSON content type.\n      return this.http.put(`${path}`, JSON.stringify(body), {\n        headers,\n        responseType: 'json'\n      })\n      // Use HttpClient to make a PUT request to the specified 'path' with a JSON-serialized 'body', headers, and a JSON response type.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    patch(path, body = {}) {\n      // Create a method 'patch' to make an HTTP PATCH request with a JSON body.\n      return this.http.patch(`${path}`, JSON.stringify(body))\n      // Use HttpClient to make a PATCH request to the specified 'path' with a JSON-serialized 'body'.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n\n    post_text(path, body = {}) {\n      // Create a method 'post_text' to make an HTTP POST request with plain text body.\n      const headers = new HttpHeaders().set('Content-Type', 'text/plain; charset=utf-8');\n      // Define headers with a text/plain content type.\n      return this.http.post(`${path}`, JSON.stringify(body), {\n        headers,\n        responseType: 'text'\n      })\n      // Use HttpClient to make a POST request to the specified 'path' with a JSON-serialized 'body', headers, and a text response type.\n      .pipe(catchError(this.formatErrors));\n      // Use the 'pipe' operator to handle errors using the 'formatErrors' method.\n    }\n    static #_ = this.ɵfac = function ApiService_Factory(t) {\n      return new (t || ApiService)(i0.ɵɵinject(i1.HttpClient));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: ApiService,\n      factory: ApiService.ɵfac\n    });\n  }\n  return ApiService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}