{"version":3,"file":"index.js","sources":["../../src/interpreter/util/proxy/can-be-observed.ts","../../src/interpreter/util/function/is-bind-call-apply.ts","../../src/interpreter/proxy/create-policy-proxy.ts","../../src/interpreter/policy/policy-trap-kind.ts","../../src/interpreter/policy/network/network-map.ts","../../src/interpreter/policy/nondeterministic/nondeterministic-map.ts","../../src/interpreter/policy/trap-condition-map.ts","../../src/interpreter/policy/is-trap-condition-met.ts","../../src/interpreter/policy/nondeterministic/is-nondeterministic.ts","../../src/interpreter/error/evaluation-error/evaluation-error.ts","../../src/interpreter/error/policy-error/policy-error.ts","../../src/interpreter/error/policy-error/non-deterministic-error/non-deterministic-error.ts","../../src/interpreter/policy/io/io-map.ts","../../src/interpreter/policy/io/is-io-read.ts","../../src/interpreter/error/policy-error/io-error/io-error.ts","../../src/interpreter/policy/io/is-io-write.ts","../../src/interpreter/policy/network/is-network-operation.ts","../../src/interpreter/error/policy-error/network-error/network-error.ts","../../src/interpreter/policy/process/process-map.ts","../../src/interpreter/policy/process/is-process-exit-operation.ts","../../src/interpreter/error/policy-error/process-error/process-error.ts","../../src/interpreter/policy/process/is-process-spawn-child-operation.ts","../../src/interpreter/policy/console/console-map.ts","../../src/interpreter/policy/console/is-console-operation.ts","../../src/interpreter/environment/create-sanitized-environment.ts","../../src/interpreter/environment/ecma/ecma-globals.ts","../../src/interpreter/util/descriptor/merge-descriptors.ts","../../src/interpreter/util/object/subtract.ts","../../src/interpreter/environment/node/node-globals.ts","../../src/interpreter/environment/environment-preset-kind.ts","../../src/interpreter/environment/browser/lib/raf.ts","../../src/interpreter/environment/browser/browser-globals.ts","../../src/interpreter/util/return/return-symbol.ts","../../src/interpreter/util/break/break-symbol.ts","../../src/interpreter/util/continue/continue-symbol.ts","../../src/interpreter/util/this/this-symbol.ts","../../src/interpreter/util/super/super-symbol.ts","../../src/interpreter/lexical-environment/lexical-environment.ts","../../src/interpreter/util/node/is-boolean-literal.ts","../../src/interpreter/util/node/is-null-literal.ts","../../src/interpreter/evaluator/simple/evaluate-simple-literal.ts","../../src/interpreter/error/policy-error/max-ops-exceeded-error/max-ops-exceeded-error.ts","../../src/interpreter/evaluator/evaluate-variable-declaration.ts","../../src/interpreter/util/node/is-this-expression.ts","../../src/interpreter/util/node/is-super-expression.ts","../../src/interpreter/lexical-environment/get-dot-path-from-node.ts","../../src/interpreter/error/unexpected-node-error/unexpected-node-error.ts","../../src/interpreter/error/undefined-left-value-error/undefined-left-value-error.ts","../../src/interpreter/evaluator/evaluate-binary-expression.ts","../../src/interpreter/literal/literal.ts","../../src/interpreter/error/not-callable-error/not-callable-error.ts","../../src/interpreter/util/expression/expression-contains-super-keyword.ts","../../src/interpreter/evaluator/evaluate-call-expression.ts","../../src/interpreter/evaluator/evaluate-parenthesized-expression.ts","../../src/interpreter/lexical-environment/clone-lexical-environment.ts","../../src/interpreter/util/modifier/has-modifier.ts","../../src/interpreter/evaluator/evaluate-parameter-declarations.ts","../../src/interpreter/evaluator/evaluate-arrow-function-expression.ts","../../src/interpreter/evaluator/evaluate-string-literal.ts","../../src/interpreter/evaluator/evaluate-numeric-literal.ts","../../src/interpreter/evaluator/evaluate-boolean-literal.ts","../../src/interpreter/evaluator/evaluate-regular-expression-literal.ts","../../src/interpreter/evaluator/evaluate-object-literal-expression.ts","../../src/interpreter/util/iterable/is-iterable.ts","../../src/interpreter/evaluator/evaluate-array-literal-expression.ts","../../src/interpreter/error/undefined-identifier-error/undefined-identifier-error.ts","../../src/interpreter/util/flags/is-var-declaration.ts","../../src/interpreter/util/node/find-nearest-parent-node-of-kind.ts","../../src/interpreter/error/module-not-found-error/module-not-found-error.ts","../../src/interpreter/util/declaration/get-declaration-name.ts","../../src/interpreter/util/module/get-implementation-for-declaration-within-declaration-file.ts","../../src/interpreter/evaluator/evaluate-identifier.ts","../../src/interpreter/evaluator/evaluate-block.ts","../../src/interpreter/evaluator/evaluate-return-statement.ts","../../src/interpreter/evaluator/evaluate-variable-declaration-list.ts","../../src/interpreter/evaluator/evaluate-variable-statement.ts","../../src/interpreter/evaluator/evaluate-prefix-unary-expression.ts","../../src/interpreter/evaluator/evaluate-property-access-expression.ts","../../src/interpreter/evaluator/evaluate-element-access-expression.ts","../../src/interpreter/evaluator/evaluate-computed-property-name.ts","../../src/interpreter/evaluator/evaluate-function-declaration.ts","../../src/interpreter/evaluator/evaluate-if-statement.ts","../../src/interpreter/evaluator/evaluate-expression-statement.ts","../../src/interpreter/evaluator/evaluate-template-expression.ts","../../src/interpreter/evaluator/evaluate-type-assertion-expression.ts","../../src/interpreter/evaluator/evaluate-postfix-unary-expression.ts","../../src/interpreter/evaluator/evaluate-new-expression.ts","../../src/interpreter/evaluator/evaluate-non-null-expression.ts","../../src/interpreter/evaluator/evaluate-as-expression.ts","../../src/interpreter/evaluator/evaluate-switch-statement.ts","../../src/interpreter/error/async-iterator-not-supported-error/async-iterator-not-supported-error.ts","../../src/interpreter/evaluator/evaluate-for-of-statement.ts","../../src/interpreter/evaluator/evaluate-this-expression.ts","../../src/interpreter/evaluator/evaluate-break-statement.ts","../../src/interpreter/evaluator/evaluate-continue-statement.ts","../../src/interpreter/evaluator/evaluate-for-statement.ts","../../src/interpreter/evaluator/evaluate-while-statement.ts","../../src/interpreter/evaluator/evaluate-for-in-statement.ts","../../src/interpreter/evaluator/evaluate-function-expression.ts","../../src/interpreter/error/missing-catch-or-finally-after-try-error/missing-catch-or-finally-after-try-error.ts","../../src/interpreter/util/try/try-symbol.ts","../../src/interpreter/evaluator/evaluate-try-statement.ts","../../src/interpreter/util/class/generate-class-declaration.ts","../../src/interpreter/evaluator/evaluate-class-declaration.ts","../../src/interpreter/evaluator/evaluate-constructor-declaration.ts","../../src/interpreter/evaluator/evaluate-super-expression.ts","../../src/interpreter/evaluator/evaluate-spread-element.ts","../../src/interpreter/evaluator/evaluate-class-expression.ts","../../src/interpreter/evaluator/evaluate-null-literal.ts","../../src/interpreter/evaluator/evaluate-void-expression.ts","../../src/interpreter/evaluator/evaluate-type-of-expression.ts","../../src/interpreter/evaluator/evaluate-big-int-literal.ts","../../src/interpreter/evaluator/evaluate-enum-declaration.ts","../../src/interpreter/evaluator/evaluate-source-file-as-namespace-object.ts","../../src/interpreter/evaluator/evaluate-module-declaration.ts","../../src/interpreter/evaluator/evaluate-import-declaration.ts","../../src/interpreter/evaluator/evaluate-throw-statement.ts","../../src/interpreter/evaluator/evaluate-import-equals-declaration.ts","../../src/interpreter/error/policy-error/max-op-duration-exceeded-error/max-op-duration-exceeded-error.ts","../../src/interpreter/evaluator/evaluate-await-expression.ts","../../src/interpreter/evaluator/evaluate-conditional-expression.ts","../../src/interpreter/util/static/in-static-context.ts","../../src/interpreter/evaluator/evaluate-method-declaration.ts","../../src/interpreter/evaluator/evaluate-property-declaration.ts","../../src/interpreter/evaluator/evaluate-get-accessor-declaration.ts","../../src/interpreter/evaluator/evaluate-type-alias-declaration.ts","../../src/interpreter/evaluator/evaluate-interface-declaration.ts","../../src/interpreter/evaluator/evaluate-node.ts","../../src/interpreter/stack/traversal-stack/statement-traversal-stack.ts","../../src/interpreter/evaluator/evaluate-statement.ts","../../src/interpreter/evaluator/evaluate-expression.ts","../../src/interpreter/evaluator/evaluate-declaration.ts","../../src/interpreter/evaluator/evaluate-binding-name.ts","../../src/interpreter/evaluator/evaluate-set-accessor-declaration.ts","../../src/interpreter/evaluator/evaluate-property-assignment.ts","../../src/interpreter/evaluator/evaluate-parameter-declaration.ts","../../src/interpreter/evaluator/evaluate-shorthand-property-assignment.ts","../../src/interpreter/evaluator/evaluate-spread-assignment.ts","../../src/interpreter/evaluator/evaluate-array-binding-pattern.ts","../../src/interpreter/evaluator/evaluate-binding-element.ts","../../src/interpreter/evaluator/evaluate-object-binding-pattern.ts","../../src/interpreter/evaluator/evaluate-case-block.ts","../../src/interpreter/evaluator/evaluate-case-clause.ts","../../src/interpreter/evaluator/evaluate-default-clause.ts","../../src/interpreter/evaluator/evaluate-catch-clause.ts","../../src/interpreter/evaluator/evaluate-omitted-expression.ts","../../src/interpreter/evaluator/evaluate-decorator.ts","../../src/interpreter/evaluator/evaluate-enum-member.ts","../../src/interpreter/evaluator/evaluate-node-with-argument.ts","../../src/interpreter/evaluator/evaluate-property-name.ts","../../src/interpreter/evaluator/evaluate-node-with-value.ts","../../src/interpreter/util/reporting/report-error.ts","../../src/interpreter/evaluator/node-evaluator/create-node-evaluator.ts","../../src/interpreter/util/syntax-kind/stringify-syntax-kind.ts","../../src/interpreter/logger/logger.ts","../../src/interpreter/util/expression/is-expression.ts","../../src/interpreter/util/statement/is-statement.ts","../../src/interpreter/stack/stack.ts","../../src/interpreter/util/declaration/is-declaration.ts","../../src/interpreter/reporting/reported-error-set.ts","../../src/interpreter/evaluate.ts"],"sourcesContent":["/**\n * Returns true if the provided value is ObjectLike\n *\n * @param value\n * @returns\n */\nexport function isObjectLike<T>(value: T): boolean {\n\treturn value != null && (typeof value === \"function\" || typeof value === \"object\");\n}\n\n/**\n * Returns true if the given value can be observed\n *\n * @param value\n * @returns\n */\nexport function canBeObserved<T>(value: T): boolean {\n\treturn isObjectLike(value);\n}\n","import {getFromLexicalEnvironment, LexicalEnvironment} from \"../../lexical-environment/lexical-environment\";\n\n/**\n * Returns true if the given function is either Function.prototype.bind, Function.prototype.call, or Function.prototype.apply\n *\n * @param func\n * @param [environment]\n * @return\n */\nexport function isBindCallApply(func: CallableFunction, environment?: LexicalEnvironment): boolean {\n\tswitch (func) {\n\t\tcase Function.prototype.bind:\n\t\tcase Function.prototype.call:\n\t\tcase Function.prototype.apply:\n\t\t\treturn true;\n\t}\n\n\tif (environment != null) {\n\t\tconst _Function = getFromLexicalEnvironment(undefined, environment, \"Function\")!.literal as CallableFunction;\n\t\tswitch (func) {\n\t\t\tcase _Function.prototype.bind:\n\t\t\tcase _Function.prototype.call:\n\t\t\tcase _Function.prototype.apply:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\nimport {canBeObserved} from \"../util/proxy/can-be-observed\";\nimport {ICreatePolicyProxyOptions} from \"./i-create-policy-proxy-options\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply\";\nimport {PolicyTrapKind} from \"../policy/policy-trap-kind\";\n\n/**\n * Stringifies the given PropertyKey path\n */\nfunction stringifyPath(path: PropertyKey[]): string {\n\treturn path.map(part => (typeof part === \"symbol\" ? part.description : part)).join(\".\");\n}\n\n/**\n * Creates a proxy with hooks to check the given policy\n */\nexport function createPolicyProxy<T extends object>({hook, item, scope, policy}: ICreatePolicyProxyOptions<T, object>): T {\n\t/**\n\t * Creates a trap that captures function invocation\n\t */\n\tfunction createAccessTrap<U extends object>(inputPath: PropertyKey[], currentItem: U): U {\n\t\treturn !canBeObserved(currentItem) || isBindCallApply(currentItem as Function)\n\t\t\t? currentItem\n\t\t\t: new Proxy(currentItem, {\n\t\t\t\t\t/**\n\t\t\t\t\t * Constructs a new instance of the given target\n\t\t\t\t\t */\n\t\t\t\t\tconstruct(target: U, argArray: unknown[], newTarget?: unknown): object {\n\t\t\t\t\t\t// Don't proceed if the hook says no\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!hook({\n\t\t\t\t\t\t\t\tkind: PolicyTrapKind.CONSTRUCT,\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\tnewTarget,\n\t\t\t\t\t\t\t\targArray,\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tpath: stringifyPath(inputPath)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Reflect.construct(target as Function, argArray, newTarget);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n\t\t\t\t\t * A trap for a function call. Used to create new proxies for methods on the retrieved module objects\n\t\t\t\t\t */\n\t\t\t\t\tapply(target: U, thisArg: unknown, argArray: unknown[] = []): unknown {\n\t\t\t\t\t\t// Don't proceed if the hook says no\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!hook({\n\t\t\t\t\t\t\t\tkind: PolicyTrapKind.APPLY,\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\tthisArg,\n\t\t\t\t\t\t\t\targArray,\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tpath: stringifyPath(inputPath)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Reflect.apply(target as Function, thisArg, argArray);\n\t\t\t\t\t},\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Gets a trap for 'get' accesses\n\t\t\t\t\t */\n\t\t\t\t\tget(target: U, property: string, receiver: unknown): unknown {\n\t\t\t\t\t\tconst newPath = [...inputPath, property];\n\n\t\t\t\t\t\t// Don't proceed if the hook says no\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!hook({\n\t\t\t\t\t\t\t\tkind: PolicyTrapKind.GET,\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\tpath: stringifyPath(newPath),\n\t\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst match = Reflect.get(target, property, receiver);\n\n\t\t\t\t\t\tconst config = Reflect.getOwnPropertyDescriptor(currentItem, property);\n\t\t\t\t\t\tif (config != null && config.configurable === false && config.writable === false) {\n\t\t\t\t\t\t\treturn currentItem[property as keyof U];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn createAccessTrap(newPath, match);\n\t\t\t\t\t}\n\t\t\t  });\n\t}\n\n\treturn !canBeObserved(item) ? item : createAccessTrap([scope], item);\n}\n","export const enum PolicyTrapKind {\n\tGET = \"__$$_PROXY_GET\",\n\tAPPLY = \"__$$_PROXY_APPLY\",\n\tCONSTRUCT = \"__$$_PROXY_CONSTRUCT\"\n}\n\n/**\n * Stringifies the given PolicyTrapKind on the given path\n *\n * @param kind\n * @param path\n * @return\n */\nexport function stringifyPolicyTrapKindOnPath(kind: PolicyTrapKind, path: string): string {\n\tswitch (kind) {\n\t\tcase PolicyTrapKind.GET:\n\t\t\treturn `get ${path}`;\n\n\t\tcase PolicyTrapKind.APPLY:\n\t\t\treturn `${path}(...)`;\n\n\t\tcase PolicyTrapKind.CONSTRUCT:\n\t\t\treturn `new ${path}(...)`;\n\t}\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const NETWORK_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\thttp2: {\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateSecureServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\n\thttps: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\trequest: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tget: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tglobalAgent: {\n\t\t\tdestroy: {\n\t\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t\t}\n\t\t},\n\t\tAgent: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\thttp: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\trequest: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tget: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tClientRequest: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tglobalAgent: {\n\t\t\tdestroy: {\n\t\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t\t}\n\t\t},\n\t\tAgent: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\tdgram: {\n\t\tcreateSocket: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\tdns: {\n\t\tlookup: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tlookupService: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve4: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve6: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveAny: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveCname: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveMx: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveNaptr: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveNs: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolvePtr: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveSoa: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveSrv: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveTxt: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\treverse: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tResolver: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\tnet: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateConnection: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\ttls: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateSecureContext: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tTLSSocket: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t}\n};\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {NETWORK_MAP} from \"../network/network-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in identifiers and the members that produce non-deterministic results.\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const NONDETERMINISTIC_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\t// Any network operation will always be non-deterministic\n\t...NETWORK_MAP,\n\tMath: {\n\t\trandom: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\tDate: {\n\t\tnow: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\t// Dates that receive no arguments are nondeterministic since they care about \"now\" and will evaluate to a new value for each invocation\n\t\t[PolicyTrapKind.CONSTRUCT]: (...args) => args.length === 0 && !(args[0] instanceof Date)\n\t}\n};\n","import {PolicyTrapKind} from \"./policy-trap-kind\";\n\nexport type TrapConditionFunction<ConditionType> = (...args: unknown[]) => ConditionType;\nexport type TrapCondition<ConditionType> = ConditionType | TrapConditionFunction<ConditionType>;\n\nexport type PolicyTrapKindToTrapConditionMap<ConditionType> = {\n\t[key in PolicyTrapKind]?: TrapCondition<ConditionType>;\n};\n\nexport type TrapConditionMap<T, ConditionType = boolean> = {\n\t[Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType>;\n};\n\nexport type TrapConditionMemberMap<T, ConditionType> = {\n\t[Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType>;\n};\n\nexport type TrapConditionMapValue<T, ConditionType> =\n\t| TrapCondition<ConditionType>\n\t| TrapConditionMemberMap<T, ConditionType>\n\t| PolicyTrapKindToTrapConditionMap<ConditionType>\n\t| undefined;\n\n/**\n * Returns true if the given item is a TrapCondition\n *\n * @param item\n * @param condition\n * @return\n */\nexport function isTrapCondition<ConditionType>(item: unknown, condition: ConditionType): item is TrapCondition<ConditionType> {\n\t// noinspection SuspiciousTypeOfGuard\n\treturn typeof item === typeof condition || typeof item === \"function\";\n}\n\n/**\n * Returns true if the given item is a TrapCondition\n *\n * @param item\n * @return\n */\nexport function isTrapConditionFunction<T, ConditionType = boolean>(item: TrapConditionMapValue<T, ConditionType>): item is TrapConditionFunction<ConditionType> {\n\treturn typeof item === \"function\";\n}\n","/* eslint-disable @typescript-eslint/ban-types */\nimport {isTrapCondition, isTrapConditionFunction, PolicyTrapKindToTrapConditionMap, TrapCondition, TrapConditionMap, TrapConditionMemberMap} from \"./trap-condition-map\";\nimport {IPolicyProxyApplyHookOptions, IPolicyProxyConstructHookOptions, PolicyProxyHookOptions} from \"../proxy/policy-proxy-hook\";\n\n/**\n * Returns true if the given path represents something that is nondeterministic.\n *\n * @param map\n * @param condition\n * @param item\n * @returns\n */\nexport function isTrapConditionMet<T extends object, ConditionType = boolean>(\n\tmap: TrapConditionMap<T, ConditionType>,\n\tcondition: ConditionType,\n\titem: PolicyProxyHookOptions<T>\n): boolean {\n\tconst atoms = item.path.split(\".\") as (keyof T)[];\n\treturn walkAtoms(map, condition, item, atoms);\n}\n\n/**\n * Walks all atoms of the given item path\n *\n * @param map\n * @param matchCondition\n * @param item\n * @param atoms\n * @return\n */\nfunction walkAtoms<T extends object, ConditionType = boolean>(\n\tmap: TrapConditionMap<T, ConditionType> | TrapConditionMemberMap<T, ConditionType>,\n\tmatchCondition: ConditionType,\n\titem: PolicyProxyHookOptions<T>,\n\tatoms: (keyof T)[]\n): boolean {\n\tconst [head, ...tail] = atoms;\n\tif (head == null) return false;\n\n\tconst mapEntry = map[head];\n\n\t// If nothing was matched within the namespace, the trap wasn't matched\n\tif (mapEntry == null) return false;\n\n\tif (isTrapCondition<ConditionType>(mapEntry, matchCondition)) {\n\t\treturn handleTrapCondition(mapEntry, matchCondition, item);\n\t} else {\n\t\tconst trapMapMatch = (mapEntry as PolicyTrapKindToTrapConditionMap<ConditionType>)[item.kind];\n\t\tif (trapMapMatch != null) {\n\t\t\treturn handleTrapCondition(trapMapMatch, matchCondition, item);\n\t\t} else {\n\t\t\treturn walkAtoms(mapEntry as TrapConditionMap<T, ConditionType> | TrapConditionMemberMap<T, ConditionType>, matchCondition, item, tail);\n\t\t}\n\t}\n}\n\n/**\n * Handles a TrapCondition\n *\n * @param trapCondition\n * @param matchCondition\n * @param item\n * @return\n */\nfunction handleTrapCondition<T extends object, ConditionType>(\n\ttrapCondition: TrapCondition<ConditionType>,\n\tmatchCondition: ConditionType,\n\titem: PolicyProxyHookOptions<T>\n): boolean {\n\t// If matching the condition depends on the provided arguments, pass them in\n\tif (isTrapConditionFunction(trapCondition)) {\n\t\tconst castItem = item as IPolicyProxyApplyHookOptions<T> | IPolicyProxyConstructHookOptions<T>;\n\t\treturn trapCondition(...castItem.argArray) === matchCondition;\n\t}\n\n\t// Otherwise, evaluate the truthiness of the condition\n\telse {\n\t\treturn trapCondition === matchCondition;\n\t}\n}\n","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {NONDETERMINISTIC_MAP} from \"./nondeterministic-map\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given path represents something that is nondeterministic.\n *\n * @param item\n * @returns\n */\nexport function isNonDeterministic(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(NONDETERMINISTIC_MAP, true, item);\n}\n","import {IEvaluationErrorOptions} from \"./i-evaluation-error-options\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * A Base class for EvaluationErrors\n */\nexport class EvaluationError extends Error {\n\t/**\n\t * The node that caused or thew the error\n\t */\n\treadonly node: TS.Node;\n\n\tconstructor({node, message}: IEvaluationErrorOptions) {\n\t\tsuper(message);\n\t\tError.captureStackTrace(this, this.constructor);\n\t\tthis.node = node;\n\t}\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IPolicyErrorOptions} from \"./i-policy-error-options\";\nimport {IEvaluatePolicySanitized} from \"../../policy/i-evaluate-policy\";\n\n/**\n * An Error that can be thrown when a policy is violated\n */\nexport class PolicyError extends EvaluationError {\n\t/**\n\t * The kind of policy violation encountered\n\t */\n\treadonly violation: keyof IEvaluatePolicySanitized;\n\n\tconstructor({violation, node, message}: IPolicyErrorOptions) {\n\t\tsuper({node, message: `[${violation}]: ${message}`});\n\t\tthis.violation = violation;\n\t}\n}\n","import {INonDeterministicErrorOptions} from \"./i-non-deterministic-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when something nondeterministic is attempted to be evaluated and has been disallowed to be so\n */\nexport class NonDeterministicError extends PolicyError {\n\t/**\n\t * The kind of operation that was attempted to be performed but was in violation of the policy\n\t */\n\treadonly operation: string;\n\n\tconstructor({operation, node, message = `The operation: '${operation}' is nondeterministic. That is in violation of the policy`}: INonDeterministicErrorOptions) {\n\t\tsuper({violation: \"deterministic\", message, node});\n\n\t\tthis.operation = operation;\n\t}\n}\n","import {TrapConditionMap} from \"../trap-condition-map\";\nimport {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {IEvaluateIOPolicy} from \"../i-evaluate-policy\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals, \"read\"|\"write\">}\n */\nexport const IO_MAP: TrapConditionMap<NodeBuiltInsAndGlobals, keyof IEvaluateIOPolicy> = {\n\tfs: {\n\t\treadFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treadFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treaddir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treaddirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tread: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treadSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\texists: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\texistsSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\taccess: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\taccessSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tclose: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcloseSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcreateReadStream: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tstat: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tstatSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\twatch: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\twatchFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tunwatchFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\trealpath: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\trealpathSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tfstat: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tfstatSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcreateWriteStream: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tcopyFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tcopyFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tunlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tunlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trmdir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trmdirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tsymlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tsymlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\ttruncate: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\ttruncateSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tutimes: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tutimesSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tappendFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tappendFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twrite: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchown: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchownSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trename: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trenameSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfutimes: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfutimesSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdtemp: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\topen: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\topenSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchown: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchownSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tftruncate: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tftruncateSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfsync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfsyncSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfdatasync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfdatasyncSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t}\n\t}\n};\n","import {IO_MAP} from \"./io-map\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given member represents a READ operation from IO\n *\n * @param item\n * @returns\n */\nexport function isIoRead(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(IO_MAP, \"read\", item);\n}\n","import {IIoErrorOptions} from \"./i-io-error-options\";\nimport {PolicyError} from \"../policy-error\";\nimport {IEvaluateIOPolicy} from \"../../../policy/i-evaluate-policy\";\n\n/**\n * An Error that can be thrown when an IO operation is attempted to be executed that is in violation of the context policy\n */\nexport class IoError extends PolicyError {\n\t/**\n\t * The kind of IO operation that was violated\n\t */\n\treadonly kind: keyof IEvaluateIOPolicy;\n\n\tconstructor({node, kind, message = `${kind} operations are in violation of the policy`}: IIoErrorOptions) {\n\t\tsuper({violation: \"io\", message, node});\n\t\tthis.kind = kind;\n\t}\n}\n","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {IO_MAP} from \"./io-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given member represents a WRITE operation from IO\n *\n * @param item\n * @returns\n */\nexport function isIoWrite(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(IO_MAP, \"write\", item);\n}\n","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {NETWORK_MAP} from \"./network-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents a network operation\n *\n * @param item\n * @returns\n */\nexport function isNetworkOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(NETWORK_MAP, true, item);\n}\n","import {INetworkErrorOptions} from \"./i-network-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when a network operation is attempted to be executed that is in violation of the context policy\n */\nexport class NetworkError extends PolicyError {\n\t/**\n\t * The kind of operation that was attempted to be performed but was in violation of the policy\n\t */\n\treadonly operation: string;\n\n\tconstructor({operation, node, message = `The operation: '${operation}' is performing network activity. That is in violation of the policy`}: INetworkErrorOptions) {\n\t\tsuper({violation: \"deterministic\", message, node});\n\n\t\tthis.operation = operation;\n\t}\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {IEvaluateProcessPolicy} from \"../i-evaluate-policy\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules (as well as 'process' and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals, string>}\n */\nexport const PROCESS_MAP: TrapConditionMap<NodeBuiltInsAndGlobals, keyof IEvaluateProcessPolicy> = {\n\tprocess: {\n\t\texit: {\n\t\t\t[PolicyTrapKind.APPLY]: \"exit\"\n\t\t}\n\t},\n\t// Everything inside child_process is just one big violation of this policy\n\tchild_process: {\n\t\t[PolicyTrapKind.APPLY]: \"spawnChild\"\n\t},\n\tcluster: {\n\t\tfork: {\n\t\t\t[PolicyTrapKind.APPLY]: \"spawnChild\"\n\t\t},\n\t\tworker: {\n\t\t\t[PolicyTrapKind.GET]: \"spawnChild\"\n\t\t},\n\t\tWorker: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: \"spawnChild\"\n\t\t},\n\t\tworkers: {\n\t\t\t[PolicyTrapKind.GET]: \"spawnChild\"\n\t\t}\n\t}\n};\n","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {PROCESS_MAP} from \"./process-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents a process operation that exits the process\n *\n * @param item\n * @returns\n */\nexport function isProcessExitOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(PROCESS_MAP, \"exit\", item);\n}\n","import {IProcessErrorOptions} from \"./i-process-error-options\";\nimport {PolicyError} from \"../policy-error\";\nimport {IEvaluateProcessPolicy} from \"../../../policy/i-evaluate-policy\";\n\n/**\n * An Error that can be thrown when a Process operation is attempted to be executed that is in violation of the context policy\n */\nexport class ProcessError extends PolicyError {\n\t/**\n\t * The kind of process operation that was violated\n\t */\n\treadonly kind: keyof IEvaluateProcessPolicy;\n\n\tconstructor({kind, node, message = `${kind} operations are in violation of the policy`}: IProcessErrorOptions) {\n\t\tsuper({violation: \"process\", message, node});\n\t\tthis.kind = kind;\n\t}\n}\n","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {PROCESS_MAP} from \"./process-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents a process operation that spawns a child\n *\n * @param item\n * @returns\n */\nexport function isProcessSpawnChildOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(PROCESS_MAP, \"spawnChild\", item);\n}\n","import {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules (as well as 'console' and the operations that print to console\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const CONSOLE_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\tconsole: {\n\t\t[PolicyTrapKind.APPLY]: true\n\t}\n};\n","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {CONSOLE_MAP} from \"./console-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents an operation that prints to console\n *\n * @param item\n * @returns\n */\nexport function isConsoleOperation(item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(CONSOLE_MAP, true, item);\n}\n","import {IndexLiteral} from \"../literal/literal\";\nimport {createPolicyProxy} from \"../proxy/create-policy-proxy\";\nimport {stringifyPolicyTrapKindOnPath} from \"../policy/policy-trap-kind\";\nimport {isNonDeterministic} from \"../policy/nondeterministic/is-nondeterministic\";\nimport {NonDeterministicError} from \"../error/policy-error/non-deterministic-error/non-deterministic-error\";\nimport {PolicyProxyHookOptions} from \"../proxy/policy-proxy-hook\";\nimport {isIoRead} from \"../policy/io/is-io-read\";\nimport {IoError} from \"../error/policy-error/io-error/io-error\";\nimport {isIoWrite} from \"../policy/io/is-io-write\";\nimport {isNetworkOperation} from \"../policy/network/is-network-operation\";\nimport {NetworkError} from \"../error/policy-error/network-error/network-error\";\nimport {isProcessExitOperation} from \"../policy/process/is-process-exit-operation\";\nimport {ProcessError} from \"../error/policy-error/process-error/process-error\";\nimport {isProcessSpawnChildOperation} from \"../policy/process/is-process-spawn-child-operation\";\nimport {ICreateSanitizedEnvironmentOptions} from \"./i-create-sanitized-environment-options\";\nimport {isConsoleOperation} from \"../policy/console/is-console-operation\";\n\n/**\n * Creates an environment that provide hooks into policy checks\n */\nexport function createSanitizedEnvironment({policy, env, getCurrentNode}: ICreateSanitizedEnvironmentOptions): IndexLiteral {\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst hook = (item: PolicyProxyHookOptions<any>) => {\n\t\tif (!policy.console && isConsoleOperation(item)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!policy.io.read && isIoRead(item)) {\n\t\t\tthrow new IoError({kind: \"read\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.io.write && isIoWrite(item)) {\n\t\t\tthrow new IoError({kind: \"write\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.process.exit && isProcessExitOperation(item)) {\n\t\t\tthrow new ProcessError({kind: \"exit\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.process.exit && isProcessSpawnChildOperation(item)) {\n\t\t\tthrow new ProcessError({kind: \"spawnChild\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.network && isNetworkOperation(item)) {\n\t\t\tthrow new NetworkError({operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode()});\n\t\t}\n\n\t\tif (policy.deterministic && isNonDeterministic(item)) {\n\t\t\tthrow new NonDeterministicError({operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode()});\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tconst descriptors = Object.entries(Object.getOwnPropertyDescriptors(env));\n\tconst gettersAndSetters = Object.assign({}, ...descriptors.filter(([, descriptor]) => !(\"value\" in descriptor)).map(([name, descriptor]) => ({[name]: descriptor})));\n\n\tconst values = Object.assign(\n\t\t{},\n\t\t...descriptors\n\t\t\t.filter(([, descriptor]) => \"value\" in descriptor)\n\t\t\t.map(([name, descriptor]) => ({\n\t\t\t\t[name]:\n\t\t\t\t\tname === \"require\"\n\t\t\t\t\t\t? new Proxy(descriptor.value as NodeRequire, {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * A trap for a function call. Used to create new proxies for methods on the retrieved module objects\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * @param target\n\t\t\t\t\t\t\t\t * @param thisArg\n\t\t\t\t\t\t\t\t * @param argArray\n\t\t\t\t\t\t\t\t * @return\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tapply(target: NodeRequire, thisArg: unknown, argArray: unknown[] = []): unknown {\n\t\t\t\t\t\t\t\t\tconst [moduleName] = argArray as string[];\n\n\t\t\t\t\t\t\t\t\treturn createPolicyProxy({\n\t\t\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\t\t\titem: Reflect.apply(target, thisArg, argArray),\n\t\t\t\t\t\t\t\t\t\tscope: moduleName,\n\t\t\t\t\t\t\t\t\t\thook\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  })\n\t\t\t\t\t\t: createPolicyProxy({\n\t\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\t\titem: descriptor.value,\n\t\t\t\t\t\t\t\tscope: name,\n\t\t\t\t\t\t\t\thook\n\t\t\t\t\t\t  })\n\t\t\t}))\n\t);\n\n\treturn Object.defineProperties(values, {\n\t\t...gettersAndSetters\n\t});\n}\n","import {IndexLiteral} from \"../../literal/literal\";\n\nexport const ECMA_GLOBALS = () => {\n\t/* eslint-disable @typescript-eslint/naming-convention */\n\tconst base: IndexLiteral = {\n\t\tInfinity,\n\t\tNaN,\n\t\tundefined,\n\t\tisNaN,\n\t\tparseFloat,\n\t\tparseInt,\n\t\tdecodeURI,\n\t\tdecodeURIComponent,\n\t\tencodeURI,\n\t\tencodeURIComponent,\n\t\tArray,\n\t\tBoolean,\n\t\tDate,\n\t\tError,\n\t\tEvalError,\n\t\tNumber,\n\t\tObject,\n\t\tRangeError,\n\t\tReferenceError,\n\t\tRegExp,\n\t\tString,\n\t\tSyntaxError,\n\t\tTypeError,\n\t\tURIError,\n\t\tJSON,\n\t\tMath,\n\t\tescape,\n\t\tunescape,\n\t\t// eslint-disable-next-line no-eval\n\t\teval,\n\t\tFunction\n\t\t/* eslint-enable @typescript-eslint/naming-convention */\n\t};\n\n\ttry {\n\t\tbase.BigInt = BigInt;\n\t} catch {}\n\n\ttry {\n\t\tbase.Reflect = Reflect;\n\t} catch {}\n\n\ttry {\n\t\tbase.WeakMap = WeakMap;\n\t} catch {}\n\n\ttry {\n\t\tbase.WeakSet = WeakSet;\n\t} catch {}\n\n\ttry {\n\t\tbase.Set = Set;\n\t} catch {}\n\n\ttry {\n\t\tbase.Map = Map;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint8Array = Uint8Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint8ClampedArray = Uint8ClampedArray;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint16Array = Uint16Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Uint32Array = Uint32Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Intl = Intl;\n\t} catch {}\n\n\ttry {\n\t\tbase.Int8Array = Int8Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Int16Array = Int16Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Int32Array = Int32Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Float32Array = Float32Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.Float64Array = Float64Array;\n\t} catch {}\n\n\ttry {\n\t\tbase.ArrayBuffer = ArrayBuffer;\n\t} catch {}\n\n\ttry {\n\t\tbase.DataView = DataView;\n\t} catch {}\n\n\ttry {\n\t\tbase.isFinite = isFinite;\n\t} catch {}\n\n\ttry {\n\t\tbase.Promise = Promise;\n\t} catch {}\n\n\ttry {\n\t\tbase.Proxy = Proxy;\n\t} catch {}\n\n\ttry {\n\t\tbase.Symbol = Symbol;\n\t} catch {}\n\n\treturn base;\n};\n","/* eslint-disable @typescript-eslint/ban-types */\n\n/**\n * Merges all of the given descriptors\n * @param {A} a\n * @return {A}\n */\nexport function mergeDescriptors<A extends object>(a: A): A;\nexport function mergeDescriptors<A extends object, B extends object>(a: A, b: B): A & B;\nexport function mergeDescriptors<A extends object, B extends object, C extends object>(a: A, b: B, c: C): A & B & C;\nexport function mergeDescriptors<A extends object, B extends object, C extends object>(a: A, b?: B, c?: C): A & B & C {\n\tconst newObj = {} as A & B & C;\n\tconst normalizedB = b == null ? {} : b;\n\tconst normalizedC = c == null ? {} : c;\n\t[a, normalizedB, normalizedC].forEach(item => Object.defineProperties(newObj, Object.getOwnPropertyDescriptors(item)));\n\treturn newObj;\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\nexport type Subtract<T, K extends Partial<T>> = {\n\t[Key in Exclude<keyof T, keyof K>]: T[Key];\n};\n\n/**\n * Excludes the properties of B from A\n */\nexport function subtract<A extends object, B extends Partial<A>>(a: A, b: B): Subtract<A, B> {\n\tconst newA = {} as Exclude<A, keyof B>;\n\tObject.getOwnPropertyNames(a).forEach(name => {\n\t\tif (!(name in b)) {\n\t\t\tObject.defineProperty(newA, name, Object.getOwnPropertyDescriptor(a, name)!);\n\t\t}\n\t});\n\treturn newA;\n}\n","import {mergeDescriptors} from \"../../util/descriptor/merge-descriptors\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals\";\nimport {subtract} from \"../../util/object/subtract\";\nimport {dirname} from \"path\";\n\nexport const NODE_GLOBALS = () => {\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\tconst merged = mergeDescriptors(subtract(global, ecmaGlobals), ecmaGlobals, {\n\t\trequire,\n\t\t__dirname: (fileName: string) => dirname(fileName),\n\t\t__filename: (fileName: string) => fileName\n\t});\n\n\tObject.defineProperties(merged, {\n\t\tglobal: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t},\n\t\tglobalThis: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn merged;\n};\n","export enum EnvironmentPresetKind {\n\tNONE = \"NONE\",\n\tECMA = \"ECMA\",\n\tBROWSER = \"BROWSER\",\n\tNODE = \"NODE\"\n}\n","export interface IRafImplementationNamespace {\n\trequestAnimationFrame(callback: FrameRequestCallback): number;\n\tcancelAnimationFrame(handle: number): void;\n}\n\n/**\n * Returns an object containing the properties that are relevant to 'requestAnimationFrame' and 'requestIdleCallback'\n */\nexport function rafImplementation(global: typeof window): IRafImplementationNamespace {\n\tlet lastTime = 0;\n\n\tconst _requestAnimationFrame = function requestAnimationFrame(callback: FrameRequestCallback): number {\n\t\tconst currTime = new Date().getTime();\n\n\t\tconst timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\n\t\tconst id = global.setTimeout(function () {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\n\t\tlastTime = currTime + timeToCall;\n\n\t\treturn id;\n\t};\n\n\tconst _cancelAnimationFrame = function cancelAnimationFrame(id: number): void {\n\t\tclearTimeout(id);\n\t};\n\n\treturn {\n\t\trequestAnimationFrame: _requestAnimationFrame,\n\t\tcancelAnimationFrame: _cancelAnimationFrame\n\t};\n}\n","import {DOMWindow, JSDOM} from \"jsdom\";\nimport {mergeDescriptors} from \"../../util/descriptor/merge-descriptors\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals\";\nimport {subtract} from \"../../util/object/subtract\";\nimport {rafImplementation} from \"./lib/raf\";\n\nexport const BROWSER_GLOBALS = () => {\n\tconst {window} = new JSDOM(\"\", {url: \"https://example.com\"});\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\tconst raf = rafImplementation((window as unknown) as Window & typeof globalThis);\n\tconst merged = mergeDescriptors(subtract(window, ecmaGlobals as Partial<DOMWindow>), subtract(raf, window), ecmaGlobals);\n\n\tObject.defineProperties(merged, {\n\t\twindow: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t},\n\t\tglobalThis: {\n\t\t\tget(): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn merged;\n};\n","export const RETURN_SYMBOL = \"[return]\";\n","export const BREAK_SYMBOL = \"[break]\";\n","export const CONTINUE_SYMBOL = \"[continue]\";\n","export const THIS_SYMBOL = \"this\";\n","export const SUPER_SYMBOL = \"super\";\n","import {IndexLiteral, Literal, LiteralMatch} from \"../literal/literal\";\nimport {del, get, has, set} from \"object-path\";\nimport {createSanitizedEnvironment} from \"../environment/create-sanitized-environment\";\nimport {ECMA_GLOBALS} from \"../environment/ecma/ecma-globals\";\nimport {NODE_GLOBALS} from \"../environment/node/node-globals\";\nimport {EnvironmentPresetKind} from \"../environment/environment-preset-kind\";\nimport {BROWSER_GLOBALS} from \"../environment/browser/browser-globals\";\nimport {mergeDescriptors} from \"../util/descriptor/merge-descriptors\";\nimport {ISetInLexicalEnvironmentOptions} from \"./i-set-in-lexical-environment-options\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {ICreateLexicalEnvironmentOptions} from \"./i-create-lexical-environment-options\";\nimport {TS} from \"../../type/ts\";\n\nexport interface LexicalEnvironment {\n\tparentEnv: LexicalEnvironment | undefined;\n\tenv: IndexLiteral;\n\tpreset?: EnvironmentPresetKind;\n}\n\n/**\n * Gets a value from a Lexical Environment\n *\n * @param env\n * @param path\n * @returns\n */\nexport function getRelevantDictFromLexicalEnvironment(env: LexicalEnvironment, path: string): LexicalEnvironment[\"env\"] | undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding)) return env.env;\n\tif (env.parentEnv != null) return getRelevantDictFromLexicalEnvironment(env.parentEnv, path);\n\treturn undefined;\n}\n\n/**\n * Gets the EnvironmentPresetKind for the given LexicalEnvironment\n */\nexport function getPresetForLexicalEnvironment(env: LexicalEnvironment): EnvironmentPresetKind {\n\tif (env.preset != null) return env.preset;\n\telse if (env.parentEnv != null) return getPresetForLexicalEnvironment(env.parentEnv);\n\telse return EnvironmentPresetKind.NONE;\n}\n\n/**\n * Gets a value from a Lexical Environment\n */\nexport function getFromLexicalEnvironment(node: TS.Node | undefined, env: LexicalEnvironment, path: string): LiteralMatch | undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding)) {\n\t\tconst literal = get(env.env, path);\n\t\tswitch (path) {\n\t\t\t// If we're in a Node environment, the \"__dirname\" and \"__filename\" meta-properties should report the current directory or file of the SourceFile and not the parent process\n\t\t\tcase \"__dirname\":\n\t\t\tcase \"__filename\": {\n\t\t\t\tconst preset = getPresetForLexicalEnvironment(env);\n\t\t\t\treturn preset === EnvironmentPresetKind.NODE && typeof literal === \"function\" && node != null ? {literal: literal(node.getSourceFile().fileName)} : {literal};\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn {literal};\n\t\t}\n\t}\n\n\tif (env.parentEnv != null) return getFromLexicalEnvironment(node, env.parentEnv, path);\n\treturn undefined;\n}\n\n/**\n * Returns true if the given lexical environment contains a value on the given path that equals the given literal\n */\nexport function pathInLexicalEnvironmentEquals(node: TS.Node, env: LexicalEnvironment, equals: Literal, ...matchPaths: string[]): boolean {\n\treturn matchPaths.some(path => {\n\t\tconst match = getFromLexicalEnvironment(node, env, path);\n\t\treturn match == null ? false : match.literal === equals;\n\t});\n}\n\n/**\n * Returns true if the given value represents an internal symbol\n *\n * @param value\n * @return\n */\nexport function isInternalSymbol(value: Literal): boolean {\n\tswitch (value) {\n\t\tcase RETURN_SYMBOL:\n\t\tcase BREAK_SYMBOL:\n\t\tcase CONTINUE_SYMBOL:\n\t\tcase THIS_SYMBOL:\n\t\tcase SUPER_SYMBOL:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Gets a value from a Lexical Environment\n *\n * @param options\n * @param [newBinding=false]\n */\nexport function setInLexicalEnvironment({env, path, value, reporting, node, newBinding = false}: ISetInLexicalEnvironmentOptions): void {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding) || newBinding || env.parentEnv == null) {\n\t\t// If the value didn't change, do no more\n\t\tif (has(env.env, path) && get(env.env, path) === value) return;\n\n\t\t// Otherwise, mutate it\n\t\tset(env.env, path, value);\n\n\t\t// Inform reporting hooks if any is given\n\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\treporting.reportBindings({path, value, node});\n\t\t}\n\t} else {\n\t\tlet currentParentEnv: LexicalEnvironment | undefined = env.parentEnv;\n\t\twhile (currentParentEnv != null) {\n\t\t\tif (has(currentParentEnv.env, firstBinding)) {\n\t\t\t\t// If the value didn't change, do no more\n\t\t\t\tif (has(currentParentEnv.env, path) && get(currentParentEnv.env, path) === value) return;\n\n\t\t\t\t// Otherwise, mutate it\n\t\t\t\tset(currentParentEnv.env, path, value);\n\n\t\t\t\t// Inform reporting hooks if any is given\n\t\t\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\t\t\treporting.reportBindings({path, value, node});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcurrentParentEnv = currentParentEnv.parentEnv;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Clears a binding from a Lexical Environment\n *\n * @param env\n * @param path\n */\nexport function clearBindingFromLexicalEnvironment(env: LexicalEnvironment, path: string): void {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding)) {\n\t\tdel(env.env, path);\n\t} else {\n\t\tlet currentParentEnv: LexicalEnvironment | undefined = env.parentEnv;\n\t\twhile (currentParentEnv != null) {\n\t\t\tif (has(currentParentEnv.env, firstBinding)) {\n\t\t\t\tdel(currentParentEnv.env, path);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcurrentParentEnv = currentParentEnv.parentEnv;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Creates a Lexical Environment\n *\n * @param options\n * @returns\n */\nexport function createLexicalEnvironment({inputEnvironment: {extra, preset}, policy, getCurrentNode}: ICreateLexicalEnvironmentOptions): LexicalEnvironment {\n\tlet envInput: IndexLiteral;\n\n\tswitch (preset) {\n\t\tcase EnvironmentPresetKind.NONE:\n\t\t\tenvInput = mergeDescriptors(extra);\n\t\t\tbreak;\n\n\t\tcase EnvironmentPresetKind.ECMA:\n\t\t\tenvInput = mergeDescriptors(ECMA_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase EnvironmentPresetKind.NODE:\n\t\t\tenvInput = mergeDescriptors(NODE_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase EnvironmentPresetKind.BROWSER:\n\t\t\tenvInput = mergeDescriptors(BROWSER_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tenvInput = {};\n\t\t\tbreak;\n\t}\n\n\treturn {\n\t\tpreset,\n\t\tparentEnv: undefined,\n\t\tenv: createSanitizedEnvironment({\n\t\t\tpolicy,\n\t\t\tenv: envInput,\n\t\t\tgetCurrentNode\n\t\t})\n\t};\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given node is a BooleanLiteral\n */\nexport function isBooleanLiteral(node: {kind: TS.SyntaxKind}, typescript: typeof TS): node is TS.Token<TS.SyntaxKind.TrueKeyword | TS.SyntaxKind.FalseKeyword> {\n\treturn node.kind === typescript.SyntaxKind.TrueKeyword || node.kind === typescript.SyntaxKind.FalseKeyword;\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given node is a NullLiteral\n */\nexport function isNullLiteral(node: TS.Node, typescript: typeof TS): node is TS.NullLiteral {\n\treturn node.kind === typescript.SyntaxKind.NullKeyword;\n}\n","import {EvaluateSimpleLiteralResult} from \"./evaluate-simple-literal-result\";\nimport {isBooleanLiteral} from \"../../util/node/is-boolean-literal\";\nimport {isNullLiteral} from \"../../util/node/is-null-literal\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * This is a tiny function that avoids the costs of building up an evaluation environment\n * for the interpreter. If the node is a simple literal, it will return its' value.\n */\nexport function evaluateSimpleLiteral(node: TS.Node, typescript: typeof TS): EvaluateSimpleLiteralResult {\n\tif (typescript.isStringLiteralLike(node)) return {success: true, value: node.text};\n\telse if (isBooleanLiteral(node, typescript)) return {success: true, value: node.kind === typescript.SyntaxKind.TrueKeyword};\n\telse if (typescript.isRegularExpressionLiteral(node)) return {success: true, value: new Function(`return ${node.text}`)()};\n\telse if (typescript.isNumericLiteral(node)) return {success: true, value: Number(node.text)};\n\telse if (typescript.isBigIntLiteral?.(node)) return {success: true, value: BigInt(node.text)};\n\telse if (typescript.isIdentifier(node) && node.text === \"Infinity\") return {success: true, value: Infinity};\n\telse if (typescript.isIdentifier(node) && node.text === \"NaN\") return {success: true, value: NaN};\n\telse if (typescript.isIdentifier(node) && node.text === \"null\") return {success: true, value: null};\n\telse if (typescript.isIdentifier(node) && node.text === \"undefined\") return {success: true, value: undefined};\n\telse if (isNullLiteral(node, typescript)) return {success: true, value: null};\n\telse return {success: false};\n}\n","import {IMaxOpsExceededErrorOptions} from \"./i-max-ops-exceeded-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded\n */\nexport class MaxOpsExceededError extends PolicyError {\n\t/**\n\t * The amount of operations performed before creating this error instance\n\t */\n\treadonly ops: number;\n\n\tconstructor({ops, node, message = `Maximum ops exceeded: ${ops}`}: IMaxOpsExceededErrorOptions) {\n\t\tsuper({violation: \"maxOps\", message, node});\n\t\tthis.ops = ops;\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {EvaluationError} from \"../error/evaluation-error/evaluation-error\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableDeclaration\n */\nexport function evaluateVariableDeclaration(\n\t{node, environment, evaluate, stack, typescript, statementTraversalStack}: IEvaluatorOptions<TS.VariableDeclaration>,\n\tinitializer?: Literal\n): void {\n\tconst initializerResult =\n\t\tinitializer != null\n\t\t\t? initializer\n\t\t\t: node.initializer == null\n\t\t\t? // A VariableDeclaration with no initializer is implicitly bound to 'undefined'\n\t\t\t  undefined\n\t\t\t: evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\t// There's no way of destructuring a nullish value\n\tif (initializerResult == null && !typescript.isIdentifier(node.name)) {\n\t\tthrow new EvaluationError({node});\n\t}\n\n\t// Evaluate the binding name\n\tevaluate.nodeWithArgument(node.name, environment, initializerResult, statementTraversalStack);\n\tstack.push(initializerResult);\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given node is a ThisExpression\n */\nexport function isThisExpression(node: TS.Node, typescript: typeof TS): node is TS.ThisExpression {\n\treturn node.kind === typescript.SyntaxKind.ThisKeyword;\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given node is a SuperExpression\n */\nexport function isSuperExpression(node: TS.Node, typescript: typeof TS): node is TS.SuperExpression {\n\treturn node.kind === typescript.SyntaxKind.SuperKeyword;\n}\n","import {isThisExpression} from \"../util/node/is-this-expression\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {isSuperExpression} from \"../util/node/is-super-expression\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {IEvaluatorOptions} from \"../evaluator/i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Gets the path to \"dot\" into an object with based on the node. For example, if the node is a simple identifier, say, 'foo', the dot path is simply \"foo\".\n * And, if it is a PropertyAccessExpression, that path may be \"console.log\" for example\n */\nexport function getDotPathFromNode<T extends TS.Node>(options: IEvaluatorOptions<T>): string | undefined {\n\tconst {node, evaluate, typescript, environment, statementTraversalStack} = options;\n\tif (typescript.isIdentifier(node)) {\n\t\treturn node.text;\n\t} else if (typescript.isPrivateIdentifier?.(node)) {\n\t\treturn node.text;\n\t} else if (isThisExpression(node, typescript)) {\n\t\treturn THIS_SYMBOL;\n\t} else if (isSuperExpression(node, typescript)) {\n\t\treturn SUPER_SYMBOL;\n\t} else if (typescript.isParenthesizedExpression(node)) {\n\t\treturn getDotPathFromNode({...options, node: node.expression});\n\t} else if (typescript.isTypeAssertion(node)) {\n\t\treturn getDotPathFromNode({...options, node: node.expression});\n\t} else if (typescript.isPropertyAccessExpression(node)) {\n\t\tlet leftHand = getDotPathFromNode({...options, node: node.expression});\n\t\tif (leftHand == null) leftHand = evaluate.expression(node.expression, environment, statementTraversalStack) as string;\n\t\tlet rightHand = getDotPathFromNode({...options, node: node.name});\n\t\tif (rightHand == null) rightHand = evaluate.expression(node.name, environment, statementTraversalStack) as string;\n\n\t\tif (leftHand == null || rightHand == null) return undefined;\n\t\treturn `${leftHand}.${rightHand}`;\n\t} else if (typescript.isElementAccessExpression(node)) {\n\t\tlet leftHand = getDotPathFromNode({...options, node: node.expression});\n\t\tif (leftHand == null) leftHand = evaluate.expression(node.expression, environment, statementTraversalStack) as string;\n\t\tconst rightHand = evaluate.expression(node.argumentExpression, environment, statementTraversalStack) as string;\n\n\t\tif (leftHand == null || rightHand == null) return undefined;\n\t\treturn `${leftHand}.${rightHand}`;\n\t} else if (typescript.isFunctionDeclaration(node)) {\n\t\tif (node.name == null) return undefined;\n\t\treturn node.name.text;\n\t}\n\n\treturn undefined;\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IUnexpectedNodeErrorOptions} from \"./i-unexpected-node-error-options\";\n\n/**\n * An Error that can be thrown when an unexpected node is encountered\n */\nexport class UnexpectedNodeError extends EvaluationError {\n\tconstructor({node, typescript, message = `Unexpected Node: '${typescript.SyntaxKind[node.kind]}'`}: IUnexpectedNodeErrorOptions) {\n\t\tsuper({message, node});\n\t}\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IUndefinedLeftValueErrorOptions} from \"./i-undefined-left-value-error-options\";\n\n/**\n * An Error that can be thrown when an undefined leftValue is encountered\n */\nexport class UndefinedLeftValueError extends EvaluationError {\n\tconstructor({node, message = `'No leftValue could be determined'`}: IUndefinedLeftValueErrorOptions) {\n\t\tsuper({message, node});\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getDotPathFromNode} from \"../lexical-environment/get-dot-path-from-node\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {UndefinedLeftValueError} from \"../error/undefined-left-value-error/undefined-left-value-error\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a BinaryExpression\n */\nexport function evaluateBinaryExpression(options: IEvaluatorOptions<TS.BinaryExpression>): Literal {\n\tconst {node, environment, evaluate, logger, statementTraversalStack, reporting, typescript} = options;\n\n\tconst leftValue = evaluate.expression(node.left, environment, statementTraversalStack) as number;\n\tconst rightValue = evaluate.expression(node.right, environment, statementTraversalStack) as number;\n\tconst leftIdentifier = getDotPathFromNode({...options, node: node.left});\n\n\tconst operator = node.operatorToken.kind;\n\tswitch (operator) {\n\t\tcase typescript.SyntaxKind.AmpersandToken: {\n\t\t\treturn leftValue & rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AmpersandAmpersandToken: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\t\treturn leftValue && rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AmpersandEqualsToken:\n\t\tcase typescript.SyntaxKind.CaretEqualsToken:\n\t\tcase typescript.SyntaxKind.BarEqualsToken:\n\t\tcase typescript.SyntaxKind.MinusEqualsToken:\n\t\tcase typescript.SyntaxKind.PlusEqualsToken:\n\t\tcase typescript.SyntaxKind.PercentEqualsToken:\n\t\tcase typescript.SyntaxKind.SlashEqualsToken:\n\t\tcase typescript.SyntaxKind.AsteriskEqualsToken:\n\t\tcase typescript.SyntaxKind.AsteriskAsteriskEqualsToken:\n\t\tcase typescript.SyntaxKind.LessThanLessThanEqualsToken:\n\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n\t\tcase typescript.SyntaxKind.QuestionQuestionEqualsToken:\n\t\tcase typescript.SyntaxKind.BarBarEqualsToken:\n\t\tcase typescript.SyntaxKind.AmpersandAmpersandEqualsToken:{\n\t\t\t// There's nothing in the engine restricting you from applying this kind of arithmetic operation on non-numeric data types\n\t\t\tlet computedValue = leftValue;\n\t\t\tswitch (operator) {\n\t\t\t\tcase typescript.SyntaxKind.AmpersandEqualsToken:\n\t\t\t\t\tcomputedValue &= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.CaretEqualsToken:\n\t\t\t\t\tcomputedValue ^= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.BarEqualsToken:\n\t\t\t\t\tcomputedValue |= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.AsteriskEqualsToken:\n\t\t\t\t\tcomputedValue *= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.AsteriskAsteriskEqualsToken:\n\t\t\t\t\tcomputedValue **= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.LessThanLessThanEqualsToken:\n\t\t\t\t\tcomputedValue <<= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n\t\t\t\t\tcomputedValue >>= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n\t\t\t\t\tcomputedValue >>>= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.MinusEqualsToken:\n\t\t\t\t\tcomputedValue -= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.PlusEqualsToken:\n\t\t\t\t\tcomputedValue += rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.PercentEqualsToken:\n\t\t\t\t\tcomputedValue %= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.SlashEqualsToken:\n\t\t\t\t\tcomputedValue /= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.QuestionQuestionEqualsToken:\n\t\t\t\t\tcomputedValue = leftValue == null ? rightValue : leftValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.BarBarEqualsToken:\n\t\t\t\t\tif (!leftValue) {\n\t\t\t\t\t\tcomputedValue = rightValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase typescript.SyntaxKind.AmpersandAmpersandEqualsToken:\n\t\t\t\t\tif (leftValue) {\n\t\t\t\t\t\tcomputedValue = rightValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Update to the left-value within the environment if it exists there and has been updated\n\t\t\tif (leftIdentifier != null) {\n\t\t\t\tsetInLexicalEnvironment({env: environment, path: leftIdentifier, value: computedValue, reporting, node});\n\t\t\t}\n\n\t\t\t// Return the computed value\n\t\t\treturn computedValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AsteriskToken: {\n\t\t\treturn leftValue * rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.AsteriskAsteriskToken: {\n\t\t\treturn leftValue ** rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.BarToken: {\n\t\t\treturn leftValue | rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.BarBarToken: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\t\treturn leftValue || rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.CaretToken: {\n\t\t\treturn leftValue ^ rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.CommaToken: {\n\t\t\treturn rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusToken:\n\t\t\treturn leftValue - rightValue;\n\n\t\tcase typescript.SyntaxKind.PlusToken:\n\t\t\tlogger.logResult(leftValue + rightValue, \"BinaryExpression (PlusToken)\");\n\t\t\treturn leftValue + rightValue;\n\n\t\tcase typescript.SyntaxKind.PercentToken:\n\t\t\treturn leftValue % rightValue;\n\n\t\tcase typescript.SyntaxKind.SlashToken:\n\t\t\treturn leftValue / rightValue;\n\n\t\tcase typescript.SyntaxKind.EqualsToken: {\n\t\t\t// Update to the left-value within the environment if it exists there and has been updated\n\t\t\tif (leftIdentifier != null) {\n\t\t\t\tsetInLexicalEnvironment({env: environment, path: leftIdentifier, value: rightValue, reporting, node});\n\t\t\t\tlogger.logBinding(leftIdentifier, rightValue, \"Assignment\");\n\t\t\t} else {\n\t\t\t\tthrow new UndefinedLeftValueError({node: node.left});\n\t\t\t}\n\n\t\t\t// The return value of an assignment is always the assigned value\n\t\t\treturn rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.EqualsEqualsToken: {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn leftValue == rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.EqualsEqualsEqualsToken: {\n\t\t\treturn leftValue === rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ExclamationEqualsToken: {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn leftValue != rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ExclamationEqualsEqualsToken: {\n\t\t\treturn leftValue !== rightValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.GreaterThanToken:\n\t\t\treturn leftValue > rightValue;\n\n\t\tcase typescript.SyntaxKind.GreaterThanEqualsToken:\n\t\t\treturn leftValue >= rightValue;\n\n\t\tcase typescript.SyntaxKind.LessThanToken:\n\t\t\treturn leftValue < rightValue;\n\n\t\tcase typescript.SyntaxKind.LessThanEqualsToken:\n\t\t\treturn leftValue <= rightValue;\n\n\t\tcase typescript.SyntaxKind.InKeyword: {\n\t\t\treturn leftValue in ((rightValue as unknown) as Record<string, unknown>);\n\t\t}\n\n\t\t// Nullish coalescing (A ?? B)\n\t\tcase typescript.SyntaxKind.QuestionQuestionToken:\n\t\t\treturn leftValue != null ? leftValue : rightValue;\n\n\t\tcase typescript.SyntaxKind.InstanceOfKeyword: {\n\t\t\treturn ((leftValue as unknown) as Record<string, unknown>) instanceof ((rightValue as unknown) as CallableFunction);\n\t\t}\n\t}\n\n\t// Throw if the operator couldn't be handled\n\tthrow new UnexpectedNodeError({node: node.operatorToken, typescript});\n}\n","// tslint:disable:no-any\n\nexport const enum LiteralFlagKind {\n\tCALL\n}\n\nexport const LAZY_CALL_FLAG = \"___lazyCallFlag\";\n\nexport interface LazyCall {\n\t[LAZY_CALL_FLAG]: LiteralFlagKind;\n\tinvoke(...args: Literal[]): Literal;\n}\n\n/**\n * Returns true if the given literal is a lazy call\n *\n * @param literal\n * @return\n */\nexport function isLazyCall(literal: Literal): literal is LazyCall {\n\treturn literal != null && typeof literal === \"object\" && LAZY_CALL_FLAG in literal;\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport type Literal = object | Function | string | number | boolean | symbol | bigint | null | undefined;\nexport interface LiteralMatch {\n\tliteral: Literal;\n}\nexport type IndexLiteralKey = string;\nexport interface IndexLiteral {\n\t[key: string]: Literal;\n}\n\n/**\n * Stringifies the given literal\n *\n * @param literal\n * @return\n */\nexport function stringifyLiteral(literal: Literal): string {\n\tif (literal === undefined) return \"undefined\";\n\telse if (literal === null) return \"null\";\n\telse if (typeof literal === \"string\") return `\"${literal}\"`;\n\treturn literal.toString();\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {INotCallableErrorOptions} from \"./i-not-callable-error-options\";\nimport {Literal, stringifyLiteral} from \"../../literal/literal\";\n\n/**\n * An Error that can be thrown when a value is attempted to be called, but isn't callable\n */\nexport class NotCallableError extends EvaluationError {\n\t/**\n\t * The non-callable value\n\t */\n\treadonly value: Literal;\n\n\tconstructor({value, node, message = `${stringifyLiteral(value)} is not a function'`}: INotCallableErrorOptions) {\n\t\tsuper({message, node});\n\t\tthis.value = value;\n\t}\n}\n","import {isSuperExpression} from \"../node/is-super-expression\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given expression contains a 'super' keyword\n */\nexport function expressionContainsSuperKeyword(expression: TS.Expression | TS.PrivateIdentifier, typescript: typeof TS): boolean {\n\tif (isSuperExpression(expression, typescript)) return true;\n\telse if (typescript.isPropertyAccessExpression(expression)) {\n\t\treturn expressionContainsSuperKeyword(expression.expression, typescript) || expressionContainsSuperKeyword(expression.name, typescript);\n\t} else if (typescript.isElementAccessExpression(expression)) {\n\t\treturn expressionContainsSuperKeyword(expression.expression, typescript) || expressionContainsSuperKeyword(expression.argumentExpression, typescript);\n\t} else if (typescript.isParenthesizedExpression(expression)) return expressionContainsSuperKeyword(expression.expression, typescript);\n\telse if (typescript.isAsExpression(expression)) return expressionContainsSuperKeyword(expression.expression, typescript);\n\telse if (typescript.isTypeAssertion(expression)) return expressionContainsSuperKeyword(expression.expression, typescript);\n\telse {\n\t\treturn false;\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isLazyCall, Literal} from \"../literal/literal\";\nimport {NotCallableError} from \"../error/not-callable-error/not-callable-error\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {expressionContainsSuperKeyword} from \"../util/expression/expression-contains-super-keyword\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a CallExpression\n */\nexport function evaluateCallExpression({node, environment, evaluate, statementTraversalStack, typescript, logger}: IEvaluatorOptions<TS.CallExpression>): Literal {\n\tconst evaluatedArgs: Literal[] = [];\n\n\tfor (let i = 0; i < node.arguments.length; i++) {\n\t\tevaluatedArgs[i] = evaluate.expression(node.arguments[i], environment, statementTraversalStack);\n\t}\n\n\t// Evaluate the expression\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack) as CallableFunction | undefined;\n\n\tif (isLazyCall(expressionResult)) {\n\t\tconst currentThisBinding = expressionContainsSuperKeyword(node.expression, typescript) ? getFromLexicalEnvironment(node, environment, THIS_SYMBOL) : undefined;\n\t\tconst value = expressionResult.invoke(currentThisBinding != null ? currentThisBinding.literal : undefined, ...evaluatedArgs);\n\t\tlogger.logResult(value, \"CallExpression\");\n\t\treturn value;\n\t}\n\n\t// Otherwise, assume that the expression still needs calling\n\telse {\n\t\t// Unless optional chaining is being used, throw a NotCallableError\n\t\tif (node.questionDotToken == null && typeof expressionResult !== \"function\") {\n\t\t\tthrow new NotCallableError({value: expressionResult, node: node.expression});\n\t\t}\n\n\t\tconst value = typeof expressionResult !== \"function\" ? undefined : expressionResult(...evaluatedArgs);\n\t\tlogger.logResult(value, \"CallExpression\");\n\t\treturn value;\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ParenthesizedExpression\n */\nexport function evaluateParenthesizedExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.ParenthesizedExpression>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {LexicalEnvironment} from \"./lexical-environment\";\n\n/**\n * Clones the given LexicalEnvironment\n */\nexport function cloneLexicalEnvironment(environment: LexicalEnvironment): LexicalEnvironment {\n\treturn {\n\t\tparentEnv: environment,\n\t\tenv: {}\n\t};\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given Node has the given kind of Modifier\n */\nexport function hasModifier(node: TS.Node | TS.Modifier[], modifier: TS.Modifier[\"kind\"]): boolean {\n\tconst modifiers = Array.isArray(node) ? node : (node.modifiers as readonly TS.Modifier[] | undefined);\n\treturn modifiers != null && modifiers.some(m => m.kind === modifier);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a NodeArray of ParameterDeclarations\n */\nexport function evaluateParameterDeclarations(\n\t{node, evaluate, environment, statementTraversalStack, typescript}: IEvaluatorOptions<TS.NodeArray<TS.ParameterDeclaration>>,\n\tboundArguments: Literal[],\n\tcontext?: IndexLiteral\n): void {\n\t// 'this' is a special parameter which is removed from the emitted results\n\tconst parameters = node.filter(param => !(typescript.isIdentifier(param.name) && param.name.text === \"this\"));\n\n\tfor (let i = 0; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\n\t\t// It it is a spread element, it should receive all arguments from the current index.\n\t\tif (parameter.dotDotDotToken != null) {\n\t\t\tevaluate.nodeWithArgument(parameter, environment, boundArguments.slice(i), statementTraversalStack);\n\t\t\t// Spread elements must always be the last parameter\n\t\t\tbreak;\n\t\t} else {\n\t\t\tevaluate.nodeWithArgument(parameter, environment, boundArguments[i], statementTraversalStack);\n\n\t\t\t// If a context is given, and if a [public|protected|private] keyword is in front of the parameter, the initialized value should be\n\t\t\t// set on the context as an instance property\n\t\t\tif (\n\t\t\t\tcontext != null &&\n\t\t\t\ttypescript.isIdentifier(parameter.name) &&\n\t\t\t\t(hasModifier(parameter, typescript.SyntaxKind.PublicKeyword) ||\n\t\t\t\t\thasModifier(parameter, typescript.SyntaxKind.ProtectedKeyword) ||\n\t\t\t\t\thasModifier(parameter, typescript.SyntaxKind.PrivateKeyword))\n\t\t\t) {\n\t\t\t\tconst value = getFromLexicalEnvironment(parameter, environment, parameter.name.text);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tcontext[parameter.name.text] = value.literal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an ArrowFunction\n */\nexport function evaluateArrowFunctionExpression(options: IEvaluatorOptions<TS.ArrowFunction>): Literal {\n\tconst {node, environment, evaluate, stack, statementTraversalStack, reporting, typescript} = options;\n\n\tconst arrowFunctionExpression = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async (...args: Literal[]) => {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (typescript.isBlock(node.body)) {\n\t\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\t\treturn stack.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\t\telse return undefined;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, the body is itself an expression\n\t\t\t\telse {\n\t\t\t\t\treturn evaluate.expression(node.body, localLexicalEnvironment, statementTraversalStack);\n\t\t\t\t}\n\t\t  }\n\t\t: (...args: Literal[]) => {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (typescript.isBlock(node.body)) {\n\t\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\t\treturn stack.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\t\telse return undefined;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, the body is itself an expression\n\t\t\t\telse {\n\t\t\t\t\treturn evaluate.expression(node.body, localLexicalEnvironment, statementTraversalStack);\n\t\t\t\t}\n\t\t  };\n\n\tarrowFunctionExpression.toString = () => `[Function: anonymous]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(arrowFunctionExpression, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\treturn arrowFunctionExpression;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a StringLiteralLike\n */\nexport function evaluateStringLiteral({node}: IEvaluatorOptions<TS.StringLiteralLike>): Literal {\n\treturn node.text;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a NumericLiteral\n */\nexport function evaluateNumericLiteral({node}: IEvaluatorOptions<TS.NumericLiteral>): Literal {\n\treturn Number(node.text);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a BooleanLiteral\n */\nexport function evaluateBooleanLiteral({node, typescript}: IEvaluatorOptions<TS.Token<TS.SyntaxKind.TrueKeyword | TS.SyntaxKind.FalseKeyword>>): Literal {\n\treturn node.kind === typescript.SyntaxKind.TrueKeyword;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a RegularExpressionLiteral\n */\nexport function evaluateRegularExpressionLiteral({node, environment}: IEvaluatorOptions<TS.RegularExpressionLiteral>): Literal {\n\tconst functionCtor = getFromLexicalEnvironment(node, environment, \"Function\")!.literal as FunctionConstructor;\n\treturn new functionCtor(`return ${node.text}`)();\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ObjectLiteralExpression\n */\nexport function evaluateObjectLiteralExpression({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<TS.ObjectLiteralExpression>): Literal {\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst value: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\n\t// Mark the object as the 'this' value of the scope\n\tsetInLexicalEnvironment({env: environment, path: THIS_SYMBOL, value, newBinding: true, reporting, node});\n\n\tfor (const property of node.properties) {\n\t\tevaluate.nodeWithArgument(property, environment, value, statementTraversalStack);\n\t}\n\n\treturn value;\n}\n","import {Literal} from \"../../literal/literal\";\n\n/**\n * Returns true if the given item is an Iterable\n *\n * @param item\n * @return\n */\nexport function isIterable(item: Literal): item is Iterable<Literal> {\n\treturn item != null && (item as Iterable<Literal>)[Symbol.iterator] != null;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {isIterable} from \"../util/iterable/is-iterable\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ArrayLiteralExpression\n */\nexport function evaluateArrayLiteralExpression({node, environment, evaluate, typescript, statementTraversalStack}: IEvaluatorOptions<TS.ArrayLiteralExpression>): Literal {\n\t// Get the Array constructor from the realm - not that of the executing context. Otherwise, instanceof checks would fail\n\tconst arrayCtor = getFromLexicalEnvironment(node, environment, \"Array\")!.literal as ArrayConstructor;\n\tconst value: Literal[] = arrayCtor.of();\n\n\tfor (const element of node.elements) {\n\t\tconst nextValue = evaluate.expression(element, environment, statementTraversalStack);\n\t\tif (typescript.isSpreadElement(element) && isIterable(nextValue)) {\n\t\t\tvalue.push(...nextValue);\n\t\t} else {\n\t\t\tvalue.push(nextValue);\n\t\t}\n\t}\n\n\treturn value;\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IUndefinedIdentifierErrorOptions} from \"./i-undefined-identifier-error-options\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * An Error that can be thrown when an undefined identifier is encountered\n */\nexport class UndefinedIdentifierError extends EvaluationError {\n\t/**\n\t * The identifier that is undefined in the context that created this error\n\t */\n\treadonly node!: TS.Identifier | TS.PrivateIdentifier;\n\n\tconstructor({node, message = `'${node.text}' is not defined'`}: IUndefinedIdentifierErrorOptions) {\n\t\tsuper({message, node});\n\t}\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given VariableDeclarationList is declared with a 'var' keyword\n */\nexport function isVarDeclaration(declarationList: TS.VariableDeclarationList, typescript: typeof TS): boolean {\n\treturn declarationList.flags !== typescript.NodeFlags.Const && declarationList.flags !== typescript.NodeFlags.Let;\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Finds the nearest parent node of the given kind from the given Node\n */\nexport function findNearestParentNodeOfKind<T extends TS.Node>(from: TS.Node, kind: TS.SyntaxKind, typescript: typeof TS): T | undefined {\n\tlet currentParent = from;\n\twhile (true) {\n\t\tcurrentParent = currentParent.parent;\n\t\tif (currentParent == null) return undefined;\n\t\tif (currentParent.kind === kind) {\n\t\t\tconst combinedNodeFlags = typescript.getCombinedNodeFlags(currentParent);\n\t\t\tconst isNamespace = (combinedNodeFlags & typescript.NodeFlags.Namespace) !== 0 || (combinedNodeFlags & typescript.NodeFlags.NestedNamespace) !== 0;\n\t\t\tif (!isNamespace) return currentParent as T;\n\t\t}\n\n\t\tif (typescript.isSourceFile(currentParent)) return undefined;\n\t}\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IModuleNotFoundErrorOptions} from \"./i-module-not-found-error-options\";\n\n/**\n * An Error that can be thrown when a moduleSpecifier couldn't be resolved\n */\nexport class ModuleNotFoundError extends EvaluationError {\n\t/**\n\t * The path/moduleName that could not be resolved\n\t */\n\treadonly path: string;\n\n\tconstructor({path, node, message = `Module '${path}' could not be resolved'`}: IModuleNotFoundErrorOptions) {\n\t\tsuper({message, node});\n\t\tthis.path = path;\n\t}\n}\n","import {IEvaluatorOptions} from \"../../evaluator/i-evaluator-options\";\nimport {UnexpectedNodeError} from \"../../error/unexpected-node-error/unexpected-node-error\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * Gets the name of the given declaration\n */\nexport function getDeclarationName({node, evaluate, environment, typescript, statementTraversalStack}: IEvaluatorOptions<TS.Declaration>): string | number | undefined {\n\tconst name = typescript.getNameOfDeclaration(node);\n\tif (name == null) return undefined;\n\n\tif (typescript.isIdentifier(name)) {\n\t\treturn name.text;\n\t} else if (typescript.isPrivateIdentifier?.(name)) {\n\t\treturn name.text;\n\t} else if (typescript.isStringLiteralLike(name)) {\n\t\treturn name.text;\n\t} else if (typescript.isNumericLiteral(name)) {\n\t\treturn Number(name.text);\n\t} else if (typescript.isComputedPropertyName(name)) {\n\t\treturn evaluate.expression(name.expression, environment, statementTraversalStack) as ReturnType<typeof getDeclarationName>;\n\t} else {\n\t\tthrow new UnexpectedNodeError({node: name, typescript});\n\t}\n}\n","import {findNearestParentNodeOfKind} from \"../node/find-nearest-parent-node-of-kind\";\nimport {Literal} from \"../../literal/literal\";\nimport {ModuleNotFoundError} from \"../../error/module-not-found-error/module-not-found-error\";\nimport {UnexpectedNodeError} from \"../../error/unexpected-node-error/unexpected-node-error\";\nimport {IEvaluatorOptions} from \"../../evaluator/i-evaluator-options\";\nimport {getDeclarationName} from \"../declaration/get-declaration-name\";\nimport {EvaluationError} from \"../../error/evaluation-error/evaluation-error\";\nimport {getFromLexicalEnvironment} from \"../../lexical-environment/lexical-environment\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * Gets an implementation for the given declaration that lives within a declaration file\n */\nexport function getImplementationForDeclarationWithinDeclarationFile(options: IEvaluatorOptions<TS.Declaration>): Literal {\n\tconst {node, typescript} = options;\n\tconst name = getDeclarationName(options);\n\n\tif (name == null) {\n\t\tthrow new UnexpectedNodeError({node, typescript});\n\t}\n\n\t// First see if it lives within the lexical environment\n\tconst matchInLexicalEnvironment = getFromLexicalEnvironment(node, options.environment, name as string);\n\t// If so, return it\n\tif (matchInLexicalEnvironment != null && matchInLexicalEnvironment.literal != null) {\n\t\treturn matchInLexicalEnvironment.literal;\n\t}\n\n\t// Otherwise, expect it to be something that is require'd on demand\n\tconst require = getFromLexicalEnvironment(node, options.environment, \"require\")!.literal as NodeRequire;\n\n\tconst moduleDeclaration = typescript.isModuleDeclaration(node)\n\t\t? node\n\t\t: findNearestParentNodeOfKind<TS.ModuleDeclaration>(node, typescript.SyntaxKind.ModuleDeclaration, typescript);\n\tif (moduleDeclaration == null) {\n\t\tthrow new UnexpectedNodeError({node, typescript});\n\t}\n\n\ttry {\n\t\t// eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires\n\t\tconst module = require(moduleDeclaration.name.text);\n\t\treturn typescript.isModuleDeclaration(node) ? module : module[name] ?? module;\n\t} catch (ex) {\n\t\tif (ex instanceof EvaluationError) throw ex;\n\t\telse throw new ModuleNotFoundError({node: moduleDeclaration, path: moduleDeclaration.name.text});\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {UndefinedIdentifierError} from \"../error/undefined-identifier-error/undefined-identifier-error\";\nimport {isVarDeclaration} from \"../util/flags/is-var-declaration\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an Identifier or a PrivateIdentifier\n */\n\nexport function evaluateIdentifier(options: IEvaluatorOptions<TS.Identifier | TS.PrivateIdentifier>): Literal {\n\tconst {node, environment, typeChecker, evaluate, stack, logger, reporting, typescript, statementTraversalStack} = options;\n\n\t// Otherwise, try to resolve it. Maybe it exists in the environment already?\n\tconst environmentMatch = getFromLexicalEnvironment(node, environment, node.text);\n\tif (environmentMatch != null) {\n\t\tlogger.logBinding(node.text, environmentMatch.literal, \"Lexical Environment match\");\n\t\t// Return the existing evaluated value from the environment\n\t\treturn environmentMatch.literal;\n\t}\n\n\t// Try to get a symbol for whatever the identifier points to and take its value declaration.\n\t// It may not have a symbol, for example if it is an inlined expression such as an initializer or a Block\n\tconst symbol = typeChecker.getSymbolAtLocation(node);\n\tlet valueDeclaration: TS.Declaration | undefined = symbol == null ? undefined : symbol.valueDeclaration;\n\n\tif (symbol != null && valueDeclaration == null) {\n\t\ttry {\n\t\t\t// The symbol may be aliasing another one - which may have a value declaration\n\t\t\tconst aliasedSymbol = typeChecker.getAliasedSymbol(symbol);\n\t\t\tvalueDeclaration = aliasedSymbol.valueDeclaration;\n\t\t} catch {\n\t\t\t// OK, it didn't alias anything\n\t\t}\n\t}\n\n\t// If it has a value declaration, go forward with that one\n\tif (valueDeclaration != null) {\n\t\tif (valueDeclaration.getSourceFile().isDeclarationFile) {\n\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile({...options, node: valueDeclaration});\n\t\t\t// Bind the value placed on the top of the stack to the local environment\n\t\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: implementation, reporting, node: valueDeclaration});\n\t\t\tlogger.logBinding(\n\t\t\t\tnode.text,\n\t\t\t\timplementation,\n\t\t\t\t`Discovered declaration value${\n\t\t\t\t\tvalueDeclaration.getSourceFile() === node.getSourceFile() ? \"\" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`\n\t\t\t\t}`\n\t\t\t);\n\t\t\treturn implementation;\n\t\t}\n\n\t\t// If the value is a variable declaration and is located *after* the current node within the SourceFile\n\t\t// It is potentially a SyntaxError unless it is hoisted (if the 'var' keyword is being used) in which case the variable is defined, but initialized to 'undefined'\n\t\tif (typescript.isVariableDeclaration(valueDeclaration) && valueDeclaration.getSourceFile().fileName === node.getSourceFile().fileName && valueDeclaration.pos > node.pos) {\n\t\t\t// The 'var' keyword declares a variable that is defined, but which rvalue is still undefined\n\t\t\tif (typescript.isVariableDeclarationList(valueDeclaration.parent) && isVarDeclaration(valueDeclaration.parent, typescript)) {\n\t\t\t\tconst returnValue = undefined;\n\t\t\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: returnValue, newBinding: true, reporting, node: valueDeclaration});\n\t\t\t\tlogger.logBinding(node.text, returnValue, \"Hoisted var declaration\");\n\t\t\t\treturn returnValue;\n\t\t\t}\n\n\t\t\t// In all other cases, both the identifier and the rvalue is still undefined\n\t\t\telse {\n\t\t\t\tthrow new UndefinedIdentifierError({node});\n\t\t\t}\n\t\t}\n\n\t\tevaluate.declaration(valueDeclaration, environment, statementTraversalStack);\n\t\tconst stackValue = stack.pop();\n\n\t\t// Bind the value placed on the top of the stack to the local environment\n\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: stackValue, reporting, node: valueDeclaration});\n\t\tlogger.logBinding(\n\t\t\tnode.text,\n\t\t\tstackValue,\n\t\t\t`Discovered declaration value${\n\t\t\t\tvalueDeclaration.getSourceFile() === node.getSourceFile() ? \"\" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`\n\t\t\t}`\n\t\t);\n\t\treturn stackValue;\n\t}\n\n\t// Otherwise throw. The identifier is unknown\n\tthrow new UndefinedIdentifierError({node});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {isSuperExpression} from \"../util/node/is-super-expression\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a Block\n */\nexport function evaluateBlock({node, environment, typescript, evaluate}: IEvaluatorOptions<TS.Block>): void {\n\t// Prepare a lexical environment for the Block context\n\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\tfor (let i = 0; i < node.statements.length; i++) {\n\t\tconst statement = node.statements[i];\n\n\t\t// Don't execute 'super()' within Constructor Blocks since this is handled in another level\n\t\tif (\n\t\t\ttypescript.isConstructorDeclaration(node.parent) &&\n\t\t\ti === 0 &&\n\t\t\ttypescript.isExpressionStatement(statement) &&\n\t\t\ttypescript.isCallExpression(statement.expression) &&\n\t\t\tisSuperExpression(statement.expression.expression, typescript)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tevaluate.statement(statement, localLexicalEnvironment);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ReturnStatement\n */\nexport function evaluateReturnStatement({node, environment, evaluate, stack, reporting, statementTraversalStack}: IEvaluatorOptions<TS.ReturnStatement>): void {\n\tsetInLexicalEnvironment({env: environment, path: RETURN_SYMBOL, value: true, reporting, node});\n\n\t// If it is a simple 'return', return undefined\n\tif (node.expression == null) {\n\t\tstack.push(undefined);\n\t} else {\n\t\tstack.push(evaluate.expression(node.expression, environment, statementTraversalStack));\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableDeclarationList\n */\nexport function evaluateVariableDeclarationList({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<TS.VariableDeclarationList>): void {\n\tfor (const declaration of node.declarations) {\n\t\tevaluate.declaration(declaration, environment, statementTraversalStack);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateVariableDeclarationList} from \"./evaluate-variable-declaration-list\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableStatement\n */\nexport function evaluateVariableStatement({node, ...rest}: IEvaluatorOptions<TS.VariableStatement>): void {\n\tevaluateVariableDeclarationList({node: node.declarationList, ...rest});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getRelevantDictFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a PrefixUnaryExpression\n */\nexport function evaluatePrefixUnaryExpression({node, environment, evaluate, reporting, typescript, statementTraversalStack}: IEvaluatorOptions<TS.PrefixUnaryExpression>): Literal {\n\tconst operandValue = evaluate.expression(node.operand, environment, statementTraversalStack) as number;\n\n\tswitch (node.operator) {\n\t\tcase typescript.SyntaxKind.PlusToken: {\n\t\t\treturn +operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusToken: {\n\t\t\treturn -operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.TildeToken: {\n\t\t\treturn ~operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.ExclamationToken: {\n\t\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\t\treturn !operandValue;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.PlusPlusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand, typescript});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text)!;\n\t\t\tconst value = ++(dict[node.operand.text]! as number);\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusMinusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand, typescript});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text)!;\n\t\t\tconst value = --(dict[node.operand.text]! as number);\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, LAZY_CALL_FLAG, LazyCall, Literal, LiteralFlagKind} from \"../literal/literal\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyAccessExpression\n */\nexport function evaluatePropertyAccessExpression({node, environment, evaluate, typescript, statementTraversalStack}: IEvaluatorOptions<TS.PropertyAccessExpression>): Literal {\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack) as IndexLiteral;\n\n\tconst match =\n\t\tnode.questionDotToken != null && expressionResult == null\n\t\t\t? // If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'\n\t\t\t  undefined\n\t\t\t: expressionResult[node.name.text];\n\n\t// If it is a function, wrap it in a lazy call to preserve implicit 'this' bindings. This is to avoid losing the 'this' binding or having to\n\t// explicitly bind a 'this' value\n\tif (typeof match === \"function\" && statementTraversalStack.includes(typescript.SyntaxKind.CallExpression)) {\n\t\treturn {\n\t\t\t[LAZY_CALL_FLAG]: LiteralFlagKind.CALL,\n\t\t\tinvoke: (overriddenThis: Record<string, unknown> | CallableFunction | undefined, ...args: Literal[]) =>\n\t\t\t\toverriddenThis != null && !isBindCallApply(match, environment)\n\t\t\t\t\t? // eslint-disable-next-line @typescript-eslint/ban-types\n\t\t\t\t\t  (expressionResult[node.name.text] as Function).call(overriddenThis, ...args)\n\t\t\t\t\t: (expressionResult[node.name.text] as CallableFunction)(...args)\n\t\t} as LazyCall;\n\t} else return match;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, IndexLiteralKey, LAZY_CALL_FLAG, LazyCall, Literal, LiteralFlagKind} from \"../literal/literal\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ElementAccessExpression\n */\nexport function evaluateElementAccessExpression({node, environment, evaluate, statementTraversalStack, typescript}: IEvaluatorOptions<TS.ElementAccessExpression>): Literal {\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack) as IndexLiteral;\n\tconst argumentExpressionResult = evaluate.expression(node.argumentExpression, environment, statementTraversalStack) as IndexLiteralKey;\n\n\tconst match =\n\t\tnode.questionDotToken != null && expressionResult == null\n\t\t\t? // If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'\n\t\t\t  undefined\n\t\t\t: expressionResult[argumentExpressionResult];\n\n\t// If it is a function, wrap it in a lazy call to preserve implicit this bindings. This is to avoid losing the this binding or having to\n\t// explicitly bind a 'this' value\n\tif (typeof match === \"function\" && statementTraversalStack.includes(typescript.SyntaxKind.CallExpression)) {\n\t\treturn {\n\t\t\t[LAZY_CALL_FLAG]: LiteralFlagKind.CALL,\n\t\t\tinvoke: (overriddenThis: Record<string, unknown> | CallableFunction | undefined, ...args: Literal[]) =>\n\t\t\t\toverriddenThis != null && !isBindCallApply(match, environment)\n\t\t\t\t\t? // eslint-disable-next-line @typescript-eslint/ban-types\n\t\t\t\t\t  (expressionResult[argumentExpressionResult] as Function).call(overriddenThis, ...args)\n\t\t\t\t\t: (expressionResult[argumentExpressionResult] as CallableFunction)(...args)\n\t\t} as LazyCall;\n\t} else return match;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ComputedPropertyName\n */\nexport function evaluateComputedPropertyName({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.ComputedPropertyName>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a FunctionDeclaration\n */\nexport function evaluateFunctionDeclaration(options: IEvaluatorOptions<TS.FunctionDeclaration>): void {\n\tconst {node, environment, evaluate, stack, reporting, typescript} = options;\n\n\tconst nameResult = node.name == null ? undefined : node.name.text;\n\n\tconst _functionDeclaration = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async function functionDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\tconst sourceFile = node.getSourceFile();\n\t\t\t\tif (nameResult != null && sourceFile.isDeclarationFile) {\n\t\t\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile(options);\n\t\t\t\t\treturn (implementation as CallableFunction)(...args);\n\t\t\t\t}\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t  }\n\t\t: function functionDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\tconst sourceFile = node.getSourceFile();\n\t\t\t\tif (nameResult != null && sourceFile.isDeclarationFile) {\n\t\t\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile(options);\n\t\t\t\t\treturn (implementation as CallableFunction)(...args);\n\t\t\t\t}\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  };\n\n\tif (nameResult != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: nameResult, value: _functionDeclaration.bind(_functionDeclaration), reporting, node});\n\t}\n\n\t_functionDeclaration.toString = () => `[Function${nameResult == null ? \"\" : `: ${nameResult}`}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(_functionDeclaration, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\tstack.push(_functionDeclaration);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an IfStatement\n */\nexport function evaluateIfStatement({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.IfStatement>): void {\n\tconst expressionValue = evaluate.expression(node.expression, environment, statementTraversalStack);\n\n\t// We have to perform a loose boolean expression here to conform with actual spec behavior\n\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\tif (expressionValue) {\n\t\t// Proceed with the truthy branch\n\t\tevaluate.statement(node.thenStatement, environment);\n\t}\n\n\t// Proceed with the falsy branch\n\telse if (node.elseStatement != null) {\n\t\treturn evaluate.statement(node.elseStatement, environment);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an ExpressionStatement\n */\nexport function evaluateExpressionStatement({node, environment, evaluate, stack, statementTraversalStack}: IEvaluatorOptions<TS.ExpressionStatement>): void {\n\tstack.push(evaluate.expression(node.expression, environment, statementTraversalStack));\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a TemplateExpression\n */\nexport function evaluateTemplateExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.TemplateExpression>): Literal {\n\tlet str = \"\";\n\tstr += node.head.text;\n\tfor (const span of node.templateSpans) {\n\t\tconst expression = evaluate.expression(span.expression, environment, statementTraversalStack) as string;\n\t\tstr += expression;\n\t\tstr += span.literal.text;\n\t}\n\treturn str;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAssertion\n */\nexport function evaluateTypeAssertion({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.TypeAssertion>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {getRelevantDictFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a PostfixUnaryExpression\n */\nexport function evaluatePostfixUnaryExpression({\n\tnode,\n\tevaluate,\n\tenvironment,\n\treporting,\n\ttypescript,\n\tstatementTraversalStack\n}: IEvaluatorOptions<TS.PostfixUnaryExpression>): Literal {\n\t// Make sure to evaluate the operand to ensure that it is found in the lexical environment\n\tevaluate.expression(node.operand, environment, statementTraversalStack);\n\n\tswitch (node.operator) {\n\t\tcase typescript.SyntaxKind.PlusPlusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand, typescript});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst value = (getRelevantDictFromLexicalEnvironment(environment, node.operand.text)![node.operand.text]! as number)++;\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tcase typescript.SyntaxKind.MinusMinusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!typescript.isIdentifier(node.operand) && !typescript.isPrivateIdentifier?.(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand, typescript});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst value = (getRelevantDictFromLexicalEnvironment(environment, node.operand.text)![node.operand.text]! as number)--;\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a NewExpression\n */\nexport function evaluateNewExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.NewExpression>): Literal {\n\tconst evaluatedArgs: Literal[] = [];\n\n\tif (node.arguments != null) {\n\t\tfor (let i = 0; i < node.arguments.length; i++) {\n\t\t\tevaluatedArgs[i] = evaluate.expression(node.arguments[i], environment, statementTraversalStack);\n\t\t}\n\t}\n\n\t// Evaluate the expression\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack) as new (...args: Literal[]) => Literal;\n\n\treturn new expressionResult(...evaluatedArgs);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a NonNullExpression\n */\nexport function evaluateNonNullExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.NonNullExpression>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an AsExpression\n */\nexport function evaluateAsExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.AsExpression>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a SwitchStatement\n */\nexport function evaluateSwitchStatement({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<TS.SwitchStatement>): void {\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);\n\tevaluate.nodeWithArgument(node.caseBlock, environment, expressionResult, statementTraversalStack);\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IAsyncIteratorNotSupportedErrorOptions} from \"./i-async-iterator-not-supported-error-options\";\n\n/**\n * An Error that can be thrown when an async iteration operation is attempted\n */\nexport class AsyncIteratorNotSupportedError extends EvaluationError {\n\tconstructor({message = `It is not possible to evaluate an async iterator'`, typescript}: IAsyncIteratorNotSupportedErrorOptions) {\n\t\tsuper({message, node: typescript.createEmptyStatement()});\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\nimport {AsyncIteratorNotSupportedError} from \"../error/async-iterator-not-supported-error/async-iterator-not-supported-error\";\n\n/**\n * Evaluates, or attempts to evaluate, a ForOfStatement\n */\nexport function evaluateForOfStatement({node, environment, evaluate, logger, reporting, typescript, statementTraversalStack}: IEvaluatorOptions<TS.ForOfStatement>): void {\n\t// Compute the 'of' part\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack) as Iterable<Literal>;\n\n\t// Ensure that the initializer is a proper VariableDeclarationList\n\tif (!typescript.isVariableDeclarationList(node.initializer)) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer, typescript});\n\t}\n\n\t// Only 1 declaration is allowed in a ForOfStatement\n\telse if (node.initializer.declarations.length > 1) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer.declarations[1], typescript});\n\t}\n\n\t// As long as we only offer a synchronous API, there's no way to evaluate an async iterator in a synchronous fashion\n\tif (node.awaitModifier != null) {\n\t\tthrow new AsyncIteratorNotSupportedError({typescript});\n\t} else {\n\t\tfor (const literal of expressionResult) {\n\t\t\t// Prepare a lexical environment for the current iteration\n\t\t\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a break symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for a continue symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], localEnvironment, literal, statementTraversalStack);\n\n\t\t\t// Evaluate the Statement\n\t\t\tevaluate.statement(node.statement, localEnvironment);\n\n\t\t\t// Check if a 'break' statement has been encountered and break if so\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\t\tlogger.logBreak(node, typescript);\n\t\t\t\tbreak;\n\t\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t\tlogger.logContinue(node, typescript);\n\t\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\t\tcontinue;\n\t\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\tlogger.logReturn(node, typescript);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ThisExpression\n */\nexport function evaluateThisExpression({node, environment}: IEvaluatorOptions<TS.ThisExpression>): Literal {\n\tconst match = getFromLexicalEnvironment(node, environment, THIS_SYMBOL);\n\treturn match == null ? undefined : match.literal;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a BreakStatement\n */\nexport function evaluateBreakStatement({environment, reporting, node}: IEvaluatorOptions<TS.BreakStatement>): void {\n\tsetInLexicalEnvironment({env: environment, path: BREAK_SYMBOL, value: true, reporting, node});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ContinueStatement\n */\nexport function evaluateContinueStatement({node, environment, reporting}: IEvaluatorOptions<TS.ContinueStatement>): void {\n\tsetInLexicalEnvironment({env: environment, path: CONTINUE_SYMBOL, value: true, reporting, node});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ForStatement\n */\nexport function evaluateForStatement({node, environment, evaluate, reporting, statementTraversalStack, typescript}: IEvaluatorOptions<TS.ForStatement>): void {\n\t// Prepare a lexical environment for the ForStatement\n\tconst forEnvironment = cloneLexicalEnvironment(environment);\n\n\t// Evaluate the initializer if it is given\n\tif (node.initializer !== undefined) {\n\t\tif (typescript.isVariableDeclarationList(node.initializer)) {\n\t\t\tfor (const declaration of node.initializer.declarations) {\n\t\t\t\tevaluate.declaration(declaration, forEnvironment, statementTraversalStack);\n\t\t\t}\n\t\t} else {\n\t\t\tevaluate.expression(node.initializer, forEnvironment, statementTraversalStack);\n\t\t}\n\t}\n\n\twhile (true) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst iterationEnvironment = cloneLexicalEnvironment(forEnvironment);\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Evaluate the condition. It may be truthy always\n\t\tconst conditionResult = node.condition == null ? true : (evaluate.expression(node.condition, forEnvironment, statementTraversalStack) as boolean);\n\n\t\t// If the condition doesn't hold, return immediately\n\t\tif (!conditionResult) return;\n\n\t\t// Execute the Statement\n\t\tevaluate.statement(node.statement, iterationEnvironment);\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tbreak;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Run the incrementor\n\t\tif (node.incrementor != null) {\n\t\t\tevaluate.expression(node.incrementor, forEnvironment, statementTraversalStack);\n\t\t}\n\n\t\t// Always run the incrementor before continuing\n\t\telse if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a WhileStatement\n */\nexport function evaluateWhileStatement({node, environment, evaluate, logger, reporting, typescript, statementTraversalStack}: IEvaluatorOptions<TS.WhileStatement>): void {\n\tlet condition = evaluate.expression(node.expression, environment, statementTraversalStack) as boolean;\n\n\twhile (condition) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst iterationEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Execute the Statement\n\t\tevaluate.statement(node.statement, iterationEnvironment);\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tlogger.logBreak(node, typescript);\n\t\t\tbreak;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, RETURN_SYMBOL)) {\n\t\t\tlogger.logReturn(node, typescript);\n\t\t\treturn;\n\t\t}\n\n\t\tcondition = evaluate.expression(node.expression, environment, statementTraversalStack) as boolean;\n\n\t\t// Always re-evaluate the condition before continuing\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\tlogger.logContinue(node, typescript);\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ForInStatement\n */\nexport function evaluateForInStatement({node, environment, evaluate, logger, reporting, typescript, statementTraversalStack}: IEvaluatorOptions<TS.ForInStatement>): void {\n\t// Compute the 'of' part\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack) as IndexLiteral;\n\n\t// Ensure that the initializer is a proper VariableDeclarationList\n\tif (!typescript.isVariableDeclarationList(node.initializer)) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer, typescript});\n\t}\n\n\t// Only 1 declaration is allowed in a ForOfStatement\n\telse if (node.initializer.declarations.length > 1) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer.declarations[1], typescript});\n\t}\n\n\tfor (const literal in expressionResult) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({env: localEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], localEnvironment, literal, statementTraversalStack);\n\n\t\t// Evaluate the Statement\n\t\tevaluate.statement(node.statement, localEnvironment);\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tlogger.logBreak(node, typescript);\n\t\t\tbreak;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\tlogger.logContinue(node, typescript);\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t} else if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\tlogger.logReturn(node, typescript);\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a FunctionExpression\n */\nexport function evaluateFunctionExpression(options: IEvaluatorOptions<TS.FunctionExpression>): Literal {\n\tconst {node, environment, evaluate, stack, reporting, typescript} = options;\n\tconst nameResult = node.name == null ? undefined : node.name.text;\n\n\tconst _functionExpression = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async function functionExpression(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  }\n\t\t: function functionExpression(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  };\n\n\tif (nameResult != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: nameResult, value: _functionExpression.bind(_functionExpression), reporting, node});\n\t}\n\n\t_functionExpression.toString = () => `[Function${nameResult == null ? \"\" : `: ${nameResult}`}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(_functionExpression, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\treturn _functionExpression;\n}\n","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IMissingCatchOrFinallyAfterTryErrorOptions} from \"./i-missing-catch-or-finally-after-try-error-options\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * An Error that can be thrown when a TryStatement is encountered without neither a catch {...} nor a finally {...} block\n */\nexport class MissingCatchOrFinallyAfterTryError extends EvaluationError {\n\t/**\n\t * The TryStatement that lacks a catch/finally block\n\t */\n\treadonly node!: TS.TryStatement;\n\n\tconstructor({node, message = `Missing catch or finally after try`}: IMissingCatchOrFinallyAfterTryErrorOptions) {\n\t\tsuper({node, message});\n\t}\n}\n","export const TRY_SYMBOL = \"[try]\";\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {MissingCatchOrFinallyAfterTryError} from \"../error/missing-catch-or-finally-after-try-error/missing-catch-or-finally-after-try-error\";\nimport {clearBindingFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TRY_SYMBOL} from \"../util/try/try-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a TryStatement\n *\n * @param options\n * @returns\n */\nexport function evaluateTryStatement({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<TS.TryStatement>): void {\n\tconst executeTry = () => {\n\t\tsetInLexicalEnvironment({env: environment, reporting, newBinding: true, node, path: TRY_SYMBOL, value: true});\n\t\t// The Block will declare an environment of its own\n\t\tevaluate.statement(node.tryBlock, environment);\n\t};\n\n\tconst executeCatch = (ex: Error) => {\n\t\tclearBindingFromLexicalEnvironment(environment, TRY_SYMBOL);\n\t\t// The CatchClause will declare an environment of its own\n\t\tevaluate.nodeWithArgument(node.catchClause!, environment, ex, statementTraversalStack);\n\t};\n\n\tconst executeFinally = () => {\n\t\tclearBindingFromLexicalEnvironment(environment, TRY_SYMBOL);\n\t\t// The Block will declare an environment of its own\n\t\tevaluate.statement(node.finallyBlock!, environment);\n\t};\n\n\t// A TryStatement must have either a catch or a finally block\n\tif (node.catchClause == null && node.finallyBlock == null) {\n\t\tthrow new MissingCatchOrFinallyAfterTryError({node});\n\t}\n\n\t// Follows the form: try {...} catch {...}\n\telse if (node.catchClause != null && node.finallyBlock == null) {\n\t\ttry {\n\t\t\texecuteTry();\n\t\t} catch (ex) {\n\t\t\texecuteCatch(ex);\n\t\t}\n\t}\n\n\t// Follows the form: try {...} catch {...} finally {...}\n\telse if (node.catchClause != null && node.finallyBlock != null) {\n\t\ttry {\n\t\t\texecuteTry();\n\t\t} catch (ex) {\n\t\t\texecuteCatch(ex);\n\t\t} finally {\n\t\t\texecuteFinally();\n\t\t}\n\t}\n\n\t// Follows the form: try {...} finally {...}\n\telse if (node.catchClause == null && node.finallyBlock != null) {\n\t\ttry {\n\t\t\texecuteTry();\n\t\t} finally {\n\t\t\texecuteFinally();\n\t\t}\n\t}\n}\n","import {IGenerateClassDeclarationOptions} from \"./i-generate-class-declaration-options\";\n\n/**\n * A function that uses 'new Function' to auto-generate a class with a dynamic name and extended type\n */\nexport function generateClassDeclaration({\n\tname,\n\textendedType,\n\tctor = () => {\n\t\t// Noop\n\t}\n}: Partial<IGenerateClassDeclarationOptions>): CallableFunction {\n\tif (extendedType == null) {\n\t\treturn new Function(\n\t\t\t\"ctor\",\n\t\t\t`return class ${name == null ? \"\" : name} {constructor () {const ctorReturnValue = ctor.call(this, ...arguments); if (ctorReturnValue != null) return ctorReturnValue;}}`\n\t\t)(ctor);\n\t} else {\n\t\treturn new Function(\n\t\t\t\"extendedType\",\n\t\t\t\"ctor\",\n\t\t\t`return class ${\n\t\t\t\tname == null ? \"\" : name\n\t\t\t} extends extendedType {constructor () {super(...arguments); const ctorReturnValue = ctor.call(this, ...arguments); if (ctorReturnValue != null) return ctorReturnValue;}}`\n\t\t)(extendedType, ctor);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {generateClassDeclaration} from \"../util/class/generate-class-declaration\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ClassDeclaration\n */\nexport function evaluateClassDeclaration({\n\tnode,\n\tenvironment,\n\tevaluate,\n\tstack,\n\tlogger,\n\treporting,\n\ttypescript,\n\tstatementTraversalStack\n}: IEvaluatorOptions<TS.ClassDeclaration>): void {\n\tlet extendedType: CallableFunction | undefined;\n\tconst ctorMember = node.members.find(typescript.isConstructorDeclaration);\n\tconst otherMembers = node.members.filter(member => !typescript.isConstructorDeclaration(member));\n\n\tlet ctor: CallableFunction | undefined;\n\tif (ctorMember != null) {\n\t\tevaluate.declaration(ctorMember, environment, statementTraversalStack);\n\t\tctor = stack.pop() as CallableFunction;\n\t}\n\n\tif (node.heritageClauses != null) {\n\t\tconst extendsClause = node.heritageClauses.find(clause => clause.token === typescript.SyntaxKind.ExtendsKeyword);\n\t\tif (extendsClause != null) {\n\t\t\tconst [firstExtendedType] = extendsClause.types;\n\t\t\tif (firstExtendedType != null) {\n\t\t\t\textendedType = evaluate.expression(firstExtendedType.expression, environment, statementTraversalStack) as CallableFunction;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst name = node.name == null ? undefined : node.name.text;\n\tlet classDeclaration = generateClassDeclaration({name, extendedType, ctor});\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [classDeclaration], statementTraversalStack);\n\t\t\tclassDeclaration = stack.pop() as CallableFunction;\n\t\t}\n\t}\n\n\tclassDeclaration.toString = () => `[Class${name == null ? \"\" : `: ${name}`}]`;\n\n\tif (name != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: name, value: classDeclaration, newBinding: true, reporting, node});\n\t}\n\n\t// Walk through all of the class members\n\tfor (const member of otherMembers) {\n\t\tevaluate.nodeWithArgument(\n\t\t\tmember,\n\t\t\tenvironment,\n\t\t\thasModifier(member, typescript.SyntaxKind.StaticKeyword) ? classDeclaration : classDeclaration.prototype,\n\t\t\tstatementTraversalStack\n\t\t);\n\t}\n\n\tlogger.logHeritage(classDeclaration);\n\tstack.push(classDeclaration);\n\tlogger.logStack(stack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ConstructorDeclaration\n */\nexport function evaluateConstructorDeclaration(options: IEvaluatorOptions<TS.ConstructorDeclaration>): void {\n\tconst {node, environment, evaluate, stack, reporting} = options;\n\n\t/**\n\t * An implementation of a constructor function\n\t */\n\tfunction constructor(this: IndexLiteral, ...args: Literal[]) {\n\t\t// Don't concern yourself with calling super here as this constructor is called immediately after calling super() in another memory representation of a class\n\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t}\n\n\t\t// Evaluate the parameters based on the given arguments\n\t\tevaluateParameterDeclarations(\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tnode: node.parameters,\n\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t},\n\t\t\targs,\n\t\t\tthis\n\t\t);\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn stack.pop();\n\t\t}\n\n\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\telse return undefined;\n\t}\n\n\tconstructor.toString = () => \"[Function: constructor]\";\n\tstack.push(constructor);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a SuperExpression\n */\nexport function evaluateSuperExpression({node, environment}: IEvaluatorOptions<TS.SuperExpression>): Literal {\n\tconst match = getFromLexicalEnvironment(node, environment, SUPER_SYMBOL);\n\treturn match == null ? undefined : match.literal;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a SpreadElement, before applying it on the given parent\n */\nexport function evaluateSpreadElement({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.SpreadElement>): Literal[] {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack) as Literal[];\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {generateClassDeclaration} from \"../util/class/generate-class-declaration\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ClassExpression\n *\n * @param options\n * @returns\n */\nexport function evaluateClassExpression({\n\tnode,\n\tenvironment,\n\tevaluate,\n\tstack,\n\tlogger,\n\treporting,\n\tstatementTraversalStack,\n\ttypescript\n}: IEvaluatorOptions<TS.ClassExpression>): Literal {\n\tlet extendedType: CallableFunction | undefined;\n\tconst ctorMember = node.members.find(typescript.isConstructorDeclaration);\n\tconst otherMembers = node.members.filter(member => !typescript.isConstructorDeclaration(member));\n\n\tlet ctor: CallableFunction | undefined;\n\tif (ctorMember != null) {\n\t\tevaluate.declaration(ctorMember, environment, statementTraversalStack);\n\t\tctor = stack.pop() as CallableFunction;\n\t}\n\n\tif (node.heritageClauses != null) {\n\t\tconst extendsClause = node.heritageClauses.find(clause => clause.token === typescript.SyntaxKind.ExtendsKeyword);\n\t\tif (extendsClause != null) {\n\t\t\tconst [firstExtendedType] = extendsClause.types;\n\t\t\tif (firstExtendedType != null) {\n\t\t\t\textendedType = evaluate.expression(firstExtendedType.expression, environment, statementTraversalStack) as CallableFunction;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst name = node.name == null ? undefined : node.name.text;\n\tlet classExpression = generateClassDeclaration({name, extendedType, ctor});\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [classExpression], statementTraversalStack);\n\t\t\tclassExpression = stack.pop() as CallableFunction;\n\t\t}\n\t}\n\n\tclassExpression.toString = () => `[Class${name == null ? \"\" : `: ${name}`}]`;\n\n\tif (name != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: name, value: classExpression, newBinding: true, reporting, node});\n\t}\n\n\t// Walk through all of the class members\n\tfor (const member of otherMembers) {\n\t\tevaluate.nodeWithArgument(member, environment, hasModifier(member, typescript.SyntaxKind.StaticKeyword) ? classExpression : classExpression.prototype, statementTraversalStack);\n\t}\n\n\tlogger.logHeritage(classExpression);\n\treturn classExpression;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a NullLiteral\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateNullLiteral(_options: IEvaluatorOptions<TS.NullLiteral>): Literal {\n\treturn null;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a VoidExpression\n *\n * @param options\n * @returns\n */\nexport function evaluateVoidExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.VoidExpression>): Literal {\n\tevaluate.expression(node.expression, environment, statementTraversalStack);\n\t// The void operator evaluates the expression and then returns undefined\n\treturn undefined;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeOfExpression\n */\nexport function evaluateTypeOfExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.TypeOfExpression>): Literal {\n\treturn typeof evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a BigIntLiteral\n */\nexport function evaluateBigIntLiteral({node, environment}: IEvaluatorOptions<TS.BigIntLiteral>): Literal {\n\t// Use BigInt from the Realm instead of the executing context such that instanceof checks won't fail, etc.\n\tconst _BigInt = getFromLexicalEnvironment(node, environment, \"BigInt\")!.literal as BigIntConstructor;\n\n\t// BigInt allows taking in strings, but they must appear as BigInt literals (e.g. \"2n\" is not allowed, but \"2\" is)\n\treturn _BigInt(node.text.endsWith(\"n\") ? node.text.slice(0, -1) : node.text);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an EnumDeclaration\n */\nexport function evaluateEnumDeclaration({node, environment, evaluate, statementTraversalStack, reporting, stack}: IEvaluatorOptions<TS.EnumDeclaration>): void {\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst enumDeclaration: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\tconst name = node.name.text;\n\n\t// Bind the Enum to the lexical environment as a new binding\n\tsetInLexicalEnvironment({env: environment, path: name, value: enumDeclaration, newBinding: true, reporting, node});\n\n\tfor (const member of node.members) {\n\t\tevaluate.nodeWithArgument(member, environment, enumDeclaration, statementTraversalStack);\n\t}\n\n\tenumDeclaration.toString = () => `[Enum: ${name}]`;\n\n\t// Push the Enum declaration on to the Stack\n\tstack.push(enumDeclaration);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a SourceFile as a namespace object\n */\nexport function evaluateSourceFileAsNamespaceObject({node, environment, evaluate, typeChecker, stack, statementTraversalStack}: IEvaluatorOptions<TS.SourceFile>): void {\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst namespaceObject: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\n\tconst moduleSymbol = typeChecker.getSymbolAtLocation(node);\n\tif (moduleSymbol != null) {\n\t\tconst exports = moduleSymbol.exports;\n\t\tif (exports != null) {\n\t\t\tfor (const [identifier, symbol] of exports.entries() as IterableIterator<[string, TS.Symbol]>) {\n\t\t\t\tconst valueDeclaration = symbol.valueDeclaration;\n\t\t\t\tif (valueDeclaration == null) return;\n\n\t\t\t\tevaluate.declaration(valueDeclaration, environment, statementTraversalStack);\n\t\t\t\tnamespaceObject[identifier] = stack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tstack.push(namespaceObject);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ModuleDeclaration\n */\nexport function evaluateModuleDeclaration(options: IEvaluatorOptions<TS.ModuleDeclaration>): void {\n\toptions.stack.push(getImplementationForDeclarationWithinDeclarationFile(options));\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportDeclaration (which is actually a Statement).\n * It will be a noop, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateImportDeclaration(_options: IEvaluatorOptions<TS.ImportDeclaration>): void {\n\t// Noop\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ThrowStatement\n */\nexport function evaluateThrowStatement({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.ThrowStatement>): void {\n\tthrow evaluate.expression(node.expression, environment, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportEqualsDeclaration (which is actually a Statement).\n * It will be a noop, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateImportEqualsDeclaration(_options: IEvaluatorOptions<TS.ImportEqualsDeclaration>): void {\n\t// Noop\n}\n","import {IMaxOpDurationExceededErrorOptions} from \"./i-max-op-duration-exceeded-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded\n */\nexport class MaxOpDurationExceededError extends PolicyError {\n\t/**\n\t * The total duration of an operation that was being performed before exceeding the limit\n\t */\n\treadonly duration: number;\n\n\tconstructor({duration, node, message = `Maximum operation duration exceeded: ${duration}`}: IMaxOpDurationExceededErrorOptions) {\n\t\tsuper({violation: \"maxOpDuration\", message, node});\n\t\tthis.duration = duration;\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {MaxOpDurationExceededError} from \"../error/policy-error/max-op-duration-exceeded-error/max-op-duration-exceeded-error\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an AwaitExpression\n */\nexport async function evaluateAwaitExpression({node, environment, evaluate, policy, statementTraversalStack}: IEvaluatorOptions<TS.AwaitExpression>): Promise<Literal> {\n\t// If a maximum duration for any operation is given, set a timeout that will throw a PolicyError when and if the duration is exceeded.\n\tconst timeout =\n\t\tpolicy.maxOpDuration === Infinity\n\t\t\t? undefined\n\t\t\t: setTimeout(() => {\n\t\t\t\t\tthrow new MaxOpDurationExceededError({duration: policy.maxOpDuration, node});\n\t\t\t  }, policy.maxOpDuration);\n\n\tconst result = evaluate.expression(node.expression, environment, statementTraversalStack) as Promise<Literal>;\n\n\t// Make sure to clear the timeout if it exists to avoid throwing unnecessarily\n\tif (timeout != null) clearTimeout(timeout);\n\n\t// Return the evaluated result\n\treturn result;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ConditionalExpression\n */\nexport function evaluateConditionalExpression({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.ConditionalExpression>): Literal {\n\tconst conditionValue = evaluate.expression(node.condition, environment, statementTraversalStack);\n\n\t// We have to perform a loose boolean expression here to conform with actual spec behavior\n\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\tif (conditionValue) {\n\t\t// Proceed with the truthy branch\n\t\treturn evaluate.expression(node.whenTrue, environment, statementTraversalStack);\n\t}\n\n\t// Proceed with the falsy branch\n\treturn evaluate.expression(node.whenFalse, environment, statementTraversalStack);\n}\n","import {hasModifier} from \"../modifier/has-modifier\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given Node exists within a static context\n */\nexport function inStaticContext(node: TS.Node, typescript: typeof TS): boolean {\n\tlet currentNode = node;\n\twhile (currentNode != null && !typescript.isSourceFile(currentNode)) {\n\t\tif (hasModifier(currentNode, typescript.SyntaxKind.StaticKeyword)) return true;\n\t\tcurrentNode = currentNode.parent;\n\t}\n\treturn false;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a MethodDeclaration, before setting it on the given parent\n */\nexport function evaluateMethodDeclaration(options: IEvaluatorOptions<TS.MethodDeclaration>, parent?: IndexLiteral): void {\n\tconst {node, environment, evaluate, stack, statementTraversalStack, reporting, typescript} = options;\n\tconst nameResult = evaluate.nodeWithValue(node.name, environment, statementTraversalStack) as IndexLiteralKey;\n\tconst isStatic = inStaticContext(node, typescript);\n\n\tif (parent == null) {\n\t\tlet updatedParent: CallableFunction & IndexLiteral;\n\t\tif (typescript.isClassLike(node.parent)) {\n\t\t\tevaluate.declaration(node.parent, environment, statementTraversalStack);\n\t\t\tupdatedParent = stack.pop() as CallableFunction & IndexLiteral;\n\t\t} else {\n\t\t\tupdatedParent = evaluate.expression(node.parent, environment, statementTraversalStack) as CallableFunction & IndexLiteral;\n\t\t}\n\t\tstack.push(isStatic ? updatedParent[nameResult] : updatedParent.prototype[nameResult]);\n\t\treturn;\n\t}\n\n\tconst _methodDeclaration = hasModifier(node, typescript.SyntaxKind.AsyncKeyword)\n\t\t? async function methodDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\t\t\tsetInLexicalEnvironment({\n\t\t\t\t\t\tenv: localLexicalEnvironment,\n\t\t\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\t\t\tnewBinding: true,\n\t\t\t\t\t\treporting,\n\t\t\t\t\t\tnode\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  }\n\t\t: function methodDeclaration(this: Literal, ...args: Literal[]) {\n\t\t\t\t// Prepare a lexical environment for the function context\n\t\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t\t// Define a new binding for the arguments given to the function\n\t\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t\tif (this != null) {\n\t\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\t\t\tsetInLexicalEnvironment({\n\t\t\t\t\t\tenv: localLexicalEnvironment,\n\t\t\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\t\t\tnewBinding: true,\n\t\t\t\t\t\treporting,\n\t\t\t\t\t\tnode\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\t\tevaluateParameterDeclarations(\n\t\t\t\t\t{\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t\t\t},\n\t\t\t\t\targs\n\t\t\t\t);\n\n\t\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\t\tif (node.body == null) return;\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t  };\n\n\t_methodDeclaration.toString = () => `[Method: ${nameResult}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(_methodDeclaration, getFromLexicalEnvironment(node, environment, \"Function\")!.literal as CallableFunction);\n\n\tparent[nameResult] = _methodDeclaration;\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [parent, nameResult], statementTraversalStack);\n\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n\t// Also loop through parameters to use their decorators, if any\n\tif (node.parameters != null) {\n\t\t// 'this' is a special parameter which is removed from the emitted results\n\t\tconst parameters = node.parameters.filter(param => !(typescript.isIdentifier(param.name) && param.name.text === \"this\"));\n\t\tfor (let i = 0; i < parameters.length; i++) {\n\t\t\tconst parameter = parameters[i];\n\t\t\tif (parameter.decorators != null) {\n\t\t\t\tfor (const decorator of parameter.decorators) {\n\t\t\t\t\tevaluate.nodeWithArgument(decorator, environment, [parent, nameResult, i], statementTraversalStack);\n\t\t\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, IndexLiteralKey} from \"../literal/literal\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyDeclaration, before applying it on the given parent\n */\nexport function evaluatePropertyDeclaration(\n\t{environment, node, evaluate, statementTraversalStack, typescript, stack}: IEvaluatorOptions<TS.PropertyDeclaration>,\n\tparent?: IndexLiteral\n): void {\n\t// Compute the property name\n\tconst propertyNameResult = evaluate.nodeWithValue(node.name, environment, statementTraversalStack) as IndexLiteralKey;\n\n\tif (parent == null) {\n\t\tevaluate.declaration(node.parent, environment, statementTraversalStack);\n\t\tconst updatedParent = stack.pop() as CallableFunction & IndexLiteral;\n\t\tconst isStatic = inStaticContext(node, typescript);\n\t\tstack.push(isStatic ? updatedParent[propertyNameResult] : updatedParent.prototype[propertyNameResult]);\n\t\treturn;\n\t}\n\n\tparent[propertyNameResult] = node.initializer == null ? undefined : evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [parent, propertyNameResult], statementTraversalStack);\n\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\tstack.pop();\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a GetAccessorDeclaration, before setting it on the given parent\n */\nexport function evaluateGetAccessorDeclaration(\n\t{node, environment, evaluate, stack, reporting, typescript, statementTraversalStack}: IEvaluatorOptions<TS.GetAccessorDeclaration>,\n\tparent?: IndexLiteral\n): void {\n\tconst nameResult = evaluate.nodeWithValue(node.name, environment, statementTraversalStack) as IndexLiteralKey;\n\tconst isStatic = inStaticContext(node, typescript);\n\n\tif (parent == null) {\n\t\tlet updatedParent: CallableFunction & IndexLiteral;\n\t\tif (typescript.isClassLike(node.parent)) {\n\t\t\tevaluate.declaration(node.parent, environment, statementTraversalStack);\n\t\t\tupdatedParent = stack.pop() as CallableFunction & IndexLiteral;\n\t\t} else {\n\t\t\tupdatedParent = evaluate.expression(node.parent, environment, statementTraversalStack) as CallableFunction & IndexLiteral;\n\t\t}\n\t\tstack.push(isStatic ? updatedParent[nameResult] : updatedParent.prototype[nameResult]);\n\t\treturn;\n\t}\n\n\t/**\n\t * An implementation of the get accessor\n\t */\n\tfunction getAccessorDeclaration(this: Literal) {\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\tsetInLexicalEnvironment({\n\t\t\t\tenv: localLexicalEnvironment,\n\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\tnewBinding: true,\n\t\t\t\treporting,\n\t\t\t\tnode\n\t\t\t});\n\t\t}\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn stack.pop();\n\t\t}\n\n\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\telse return undefined;\n\t}\n\n\tgetAccessorDeclaration.toString = () => `[Get: ${nameResult}]`;\n\n\tlet currentPropertyDescriptor = Object.getOwnPropertyDescriptor(parent, nameResult);\n\tif (currentPropertyDescriptor == null) currentPropertyDescriptor = {};\n\n\tObject.defineProperty(parent, nameResult, {\n\t\t...currentPropertyDescriptor,\n\t\tconfigurable: true,\n\t\tget: getAccessorDeclaration\n\t});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAliasDeclaration\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateTypeAliasDeclaration(_options: IEvaluatorOptions<TS.TypeAliasDeclaration>): void {\n\treturn;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAliasDeclaration\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateInterfaceDeclaration(_options: IEvaluatorOptions<TS.InterfaceDeclaration>): void {\n\treturn;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateVariableDeclaration} from \"./evaluate-variable-declaration\";\nimport {evaluateBinaryExpression} from \"./evaluate-binary-expression\";\nimport {evaluateCallExpression} from \"./evaluate-call-expression\";\nimport {evaluateParenthesizedExpression} from \"./evaluate-parenthesized-expression\";\nimport {evaluateArrowFunctionExpression} from \"./evaluate-arrow-function-expression\";\nimport {evaluateStringLiteral} from \"./evaluate-string-literal\";\nimport {evaluateNumericLiteral} from \"./evaluate-numeric-literal\";\nimport {evaluateBooleanLiteral} from \"./evaluate-boolean-literal\";\nimport {evaluateRegularExpressionLiteral} from \"./evaluate-regular-expression-literal\";\nimport {evaluateObjectLiteralExpression} from \"./evaluate-object-literal-expression\";\nimport {evaluateArrayLiteralExpression} from \"./evaluate-array-literal-expression\";\nimport {evaluateIdentifier} from \"./evaluate-identifier\";\nimport {evaluateBlock} from \"./evaluate-block\";\nimport {evaluateReturnStatement} from \"./evaluate-return-statement\";\nimport {evaluateVariableStatement} from \"./evaluate-variable-statement\";\nimport {evaluateVariableDeclarationList} from \"./evaluate-variable-declaration-list\";\nimport {evaluatePrefixUnaryExpression} from \"./evaluate-prefix-unary-expression\";\nimport {evaluatePropertyAccessExpression} from \"./evaluate-property-access-expression\";\nimport {evaluateElementAccessExpression} from \"./evaluate-element-access-expression\";\nimport {evaluateComputedPropertyName} from \"./evaluate-computed-property-name\";\nimport {evaluateFunctionDeclaration} from \"./evaluate-function-declaration\";\nimport {evaluateIfStatement} from \"./evaluate-if-statement\";\nimport {evaluateExpressionStatement} from \"./evaluate-expression-statement\";\nimport {evaluateTemplateExpression} from \"./evaluate-template-expression\";\nimport {evaluateTypeAssertion} from \"./evaluate-type-assertion-expression\";\nimport {evaluatePostfixUnaryExpression} from \"./evaluate-postfix-unary-expression\";\nimport {evaluateNewExpression} from \"./evaluate-new-expression\";\nimport {evaluateNonNullExpression} from \"./evaluate-non-null-expression\";\nimport {evaluateAsExpression} from \"./evaluate-as-expression\";\nimport {evaluateSwitchStatement} from \"./evaluate-switch-statement\";\nimport {evaluateForOfStatement} from \"./evaluate-for-of-statement\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {isBooleanLiteral} from \"../util/node/is-boolean-literal\";\nimport {isThisExpression} from \"../util/node/is-this-expression\";\nimport {evaluateThisExpression} from \"./evaluate-this-expression\";\nimport {evaluateBreakStatement} from \"./evaluate-break-statement\";\nimport {evaluateContinueStatement} from \"./evaluate-continue-statement\";\nimport {evaluateForStatement} from \"./evaluate-for-statement\";\nimport {evaluateWhileStatement} from \"./evaluate-while-statement\";\nimport {evaluateForInStatement} from \"./evaluate-for-in-statement\";\nimport {evaluateFunctionExpression} from \"./evaluate-function-expression\";\nimport {evaluateTryStatement} from \"./evaluate-try-statement\";\nimport {evaluateClassDeclaration} from \"./evaluate-class-declaration\";\nimport {evaluateConstructorDeclaration} from \"./evaluate-constructor-declaration\";\nimport {isSuperExpression} from \"../util/node/is-super-expression\";\nimport {evaluateSuperExpression} from \"./evaluate-super-expression\";\nimport {evaluateSpreadElement} from \"./evaluate-spread-element\";\nimport {evaluateClassExpression} from \"./evaluate-class-expression\";\nimport {isNullLiteral} from \"../util/node/is-null-literal\";\nimport {evaluateNullLiteral} from \"./evaluate-null-literal\";\nimport {evaluateVoidExpression} from \"./evaluate-void-expression\";\nimport {evaluateTypeOfExpression} from \"./evaluate-type-of-expression\";\nimport {evaluateBigIntLiteral} from \"./evaluate-big-int-literal\";\nimport {evaluateEnumDeclaration} from \"./evaluate-enum-declaration\";\nimport {evaluateSourceFileAsNamespaceObject} from \"./evaluate-source-file-as-namespace-object\";\nimport {evaluateModuleDeclaration} from \"./evaluate-module-declaration\";\nimport {evaluateImportDeclaration} from \"./evaluate-import-declaration\";\nimport {evaluateThrowStatement} from \"./evaluate-throw-statement\";\nimport {evaluateImportEqualsDeclaration} from \"./evaluate-import-equals-declaration\";\nimport {evaluateAwaitExpression} from \"./evaluate-await-expression\";\nimport {evaluateConditionalExpression} from \"./evaluate-conditional-expression\";\nimport {evaluateMethodDeclaration} from \"./evaluate-method-declaration\";\nimport {evaluatePropertyDeclaration} from \"./evaluate-property-declaration\";\nimport {evaluateGetAccessorDeclaration} from \"./evaluate-get-accessor-declaration\";\nimport {TS} from \"../../type/ts\";\nimport {evaluateTypeAliasDeclaration} from \"./evaluate-type-alias-declaration\";\nimport {evaluateInterfaceDeclaration} from \"./evaluate-interface-declaration\";\n\n/**\n * Will get a literal value for the given Node. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateNode({node, ...rest}: IEvaluatorOptions<TS.Node>): unknown {\n\tif (rest.typescript.isIdentifier(node)) {\n\t\treturn evaluateIdentifier({node, ...rest});\n\t} else if (rest.typescript.isPrivateIdentifier?.(node)) {\n\t\treturn evaluateIdentifier({node, ...rest});\n\t} else if (rest.typescript.isStringLiteralLike(node)) {\n\t\treturn evaluateStringLiteral({node, ...rest});\n\t} else if (rest.typescript.isNumericLiteral(node)) {\n\t\treturn evaluateNumericLiteral({node, ...rest});\n\t} else if (isBooleanLiteral(node, rest.typescript)) {\n\t\treturn evaluateBooleanLiteral({node, ...rest});\n\t} else if (rest.typescript.isForOfStatement(node)) {\n\t\treturn evaluateForOfStatement({node, ...rest});\n\t} else if (rest.typescript.isForInStatement(node)) {\n\t\treturn evaluateForInStatement({node, ...rest});\n\t} else if (rest.typescript.isForStatement(node)) {\n\t\treturn evaluateForStatement({node, ...rest});\n\t} else if (rest.typescript.isWhileStatement(node)) {\n\t\treturn evaluateWhileStatement({node, ...rest});\n\t} else if (rest.typescript.isRegularExpressionLiteral(node)) {\n\t\treturn evaluateRegularExpressionLiteral({node, ...rest});\n\t} else if (rest.typescript.isObjectLiteralExpression(node)) {\n\t\treturn evaluateObjectLiteralExpression({node, ...rest});\n\t} else if (rest.typescript.isAwaitExpression(node)) {\n\t\treturn evaluateAwaitExpression({node, ...rest});\n\t} else if (rest.typescript.isTypeAssertionExpression?.(node) || rest.typescript.isTypeAssertion(node)) {\n\t\treturn evaluateTypeAssertion({node, ...rest});\n\t} else if (rest.typescript.isTemplateExpression(node)) {\n\t\treturn evaluateTemplateExpression({node, ...rest});\n\t} else if (rest.typescript.isMethodDeclaration(node)) {\n\t\treturn evaluateMethodDeclaration({node, ...rest});\n\t} else if (rest.typescript.isPropertyDeclaration(node)) {\n\t\treturn evaluatePropertyDeclaration({node, ...rest});\n\t} else if (rest.typescript.isGetAccessorDeclaration(node)) {\n\t\treturn evaluateGetAccessorDeclaration({node, ...rest});\n\t} else if (rest.typescript.isArrayLiteralExpression(node)) {\n\t\treturn evaluateArrayLiteralExpression({node, ...rest});\n\t} else if (rest.typescript.isSourceFile(node)) {\n\t\treturn evaluateSourceFileAsNamespaceObject({node, ...rest});\n\t} else if (rest.typescript.isModuleDeclaration(node)) {\n\t\treturn evaluateModuleDeclaration({node, ...rest});\n\t} else if (rest.typescript.isPrefixUnaryExpression(node)) {\n\t\treturn evaluatePrefixUnaryExpression({node, ...rest});\n\t} else if (rest.typescript.isPostfixUnaryExpression(node)) {\n\t\treturn evaluatePostfixUnaryExpression({node, ...rest});\n\t} else if (rest.typescript.isVariableStatement(node)) {\n\t\treturn evaluateVariableStatement({node, ...rest});\n\t} else if (rest.typescript.isComputedPropertyName(node)) {\n\t\treturn evaluateComputedPropertyName({node, ...rest});\n\t} else if (rest.typescript.isVariableDeclarationList(node)) {\n\t\treturn evaluateVariableDeclarationList({node, ...rest});\n\t} else if (rest.typescript.isImportDeclaration(node)) {\n\t\treturn evaluateImportDeclaration({node, ...rest});\n\t} else if (rest.typescript.isImportEqualsDeclaration(node)) {\n\t\treturn evaluateImportEqualsDeclaration({node, ...rest});\n\t} else if (rest.typescript.isThrowStatement(node)) {\n\t\treturn evaluateThrowStatement({node, ...rest});\n\t} else if (rest.typescript.isVariableDeclaration(node)) {\n\t\treturn evaluateVariableDeclaration({node, ...rest});\n\t} else if (rest.typescript.isEnumDeclaration(node)) {\n\t\treturn evaluateEnumDeclaration({node, ...rest});\n\t} else if (rest.typescript.isConstructorDeclaration(node)) {\n\t\treturn evaluateConstructorDeclaration({node, ...rest});\n\t} else if (rest.typescript.isBinaryExpression(node)) {\n\t\treturn evaluateBinaryExpression({node, ...rest});\n\t} else if (rest.typescript.isParenthesizedExpression(node)) {\n\t\treturn evaluateParenthesizedExpression({node, ...rest});\n\t} else if (rest.typescript.isExpressionStatement(node)) {\n\t\treturn evaluateExpressionStatement({node, ...rest});\n\t} else if (rest.typescript.isArrowFunction(node)) {\n\t\treturn evaluateArrowFunctionExpression({node, ...rest});\n\t} else if (rest.typescript.isFunctionDeclaration(node)) {\n\t\treturn evaluateFunctionDeclaration({node, ...rest});\n\t} else if (rest.typescript.isFunctionExpression(node)) {\n\t\treturn evaluateFunctionExpression({node, ...rest});\n\t} else if (rest.typescript.isClassDeclaration(node)) {\n\t\treturn evaluateClassDeclaration({node, ...rest});\n\t} else if (rest.typescript.isIfStatement(node)) {\n\t\treturn evaluateIfStatement({node, ...rest});\n\t} else if (rest.typescript.isConditionalExpression(node)) {\n\t\treturn evaluateConditionalExpression({node, ...rest});\n\t} else if (rest.typescript.isPropertyAccessExpression(node)) {\n\t\treturn evaluatePropertyAccessExpression({node, ...rest});\n\t} else if (rest.typescript.isElementAccessExpression(node)) {\n\t\treturn evaluateElementAccessExpression({node, ...rest});\n\t} else if (rest.typescript.isCallExpression(node)) {\n\t\treturn evaluateCallExpression({node, ...rest});\n\t} else if (rest.typescript.isSwitchStatement(node)) {\n\t\treturn evaluateSwitchStatement({node, ...rest});\n\t} else if (rest.typescript.isNewExpression(node)) {\n\t\treturn evaluateNewExpression({node, ...rest});\n\t} else if (rest.typescript.isNonNullExpression(node)) {\n\t\treturn evaluateNonNullExpression({node, ...rest});\n\t} else if (rest.typescript.isAsExpression(node)) {\n\t\treturn evaluateAsExpression({node, ...rest});\n\t} else if (rest.typescript.isBlock(node)) {\n\t\treturn evaluateBlock({node, ...rest});\n\t} else if (rest.typescript.isClassExpression(node)) {\n\t\treturn evaluateClassExpression({node, ...rest});\n\t} else if (rest.typescript.isSpreadElement(node)) {\n\t\treturn evaluateSpreadElement({node, ...rest});\n\t} else if (rest.typescript.isTryStatement(node)) {\n\t\treturn evaluateTryStatement({node, ...rest});\n\t} else if (rest.typescript.isReturnStatement(node)) {\n\t\treturn evaluateReturnStatement({node, ...rest});\n\t} else if (isThisExpression(node, rest.typescript)) {\n\t\treturn evaluateThisExpression({node, ...rest});\n\t} else if (rest.typescript.isVoidExpression(node)) {\n\t\treturn evaluateVoidExpression({node, ...rest});\n\t} else if (rest.typescript.isTypeOfExpression(node)) {\n\t\treturn evaluateTypeOfExpression({node, ...rest});\n\t} else if (isSuperExpression(node, rest.typescript)) {\n\t\treturn evaluateSuperExpression({node, ...rest});\n\t} else if (isNullLiteral(node, rest.typescript)) {\n\t\treturn evaluateNullLiteral({node, ...rest});\n\t} else if (rest.typescript.isBigIntLiteral?.(node)) {\n\t\treturn evaluateBigIntLiteral({node, ...rest});\n\t} else if (rest.typescript.isBreakStatement(node)) {\n\t\treturn evaluateBreakStatement({node, ...rest});\n\t} else if (rest.typescript.isContinueStatement(node)) {\n\t\treturn evaluateContinueStatement({node, ...rest});\n\t} else if (rest.typescript.isTypeAliasDeclaration(node)) {\n\t\treturn evaluateTypeAliasDeclaration({node, ...rest});\n\t} else if (rest.typescript.isInterfaceDeclaration(node)) {\n\t\treturn evaluateInterfaceDeclaration({node, ...rest});\n\t}\n\n\tthrow new UnexpectedNodeError({node, typescript: rest.typescript});\n}\n","import {TS} from \"../../../type/ts\";\n\nexport type StatementTraversalStack = TS.SyntaxKind[];\n\n/**\n * Creates a StatementTraversalStack\n */\nexport function createStatementTraversalStack(): StatementTraversalStack {\n\treturn [];\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateNode} from \"./evaluate-node\";\nimport {createStatementTraversalStack} from \"../stack/traversal-stack/statement-traversal-stack\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Will get a literal value for the given Statement. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateStatement(options: IEvaluatorOptions<TS.Statement>): void {\n\toptions.logger.logNode(options.node, options.typescript);\n\n\t// Create a new Statement traversal stack (since this is a new statement)\n\toptions.statementTraversalStack = createStatementTraversalStack();\n\n\tevaluateNode(options);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateNode} from \"./evaluate-node\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Will get a literal value for the given Expression. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateExpression(options: IEvaluatorOptions<TS.Expression | TS.PrivateIdentifier>): Literal {\n\toptions.logger.logNode(options.node, options.typescript);\n\tconst value = evaluateNode(options) as Promise<Literal>;\n\n\t// Report intermediate results\n\tif (options.reporting.reportIntermediateResults != null) {\n\t\toptions.reporting.reportIntermediateResults({\n\t\t\tnode: options.node,\n\t\t\tvalue\n\t\t});\n\t}\n\n\treturn value;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateNode} from \"./evaluate-node\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Will get a literal value for the given Declaration. If it doesn't succeed, the value will be 'undefined'\n */\nexport function evaluateDeclaration(options: IEvaluatorOptions<TS.Declaration>): void {\n\toptions.logger.logNode(options.node, options.typescript);\n\n\tevaluateNode(options);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a BindingName, based on an initializer\n */\nexport function evaluateBindingName(\n\t{node, environment, evaluate, statementTraversalStack, reporting, typescript, logger}: IEvaluatorOptions<TS.BindingName>,\n\trightHandValue: Literal\n): void {\n\t// If the declaration binds a simple identifier, bind that text to the environment\n\tif (typescript.isIdentifier(node) || typescript.isPrivateIdentifier?.(node)) {\n\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: rightHandValue, newBinding: true, reporting, node});\n\t\tlogger.logBinding(node.text, rightHandValue, \"evaluateBindingName\");\n\t} else {\n\t\tevaluate.nodeWithArgument(node, environment, rightHandValue, statementTraversalStack);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {LexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a SetAccessorDeclaration, before setting it on the given parent\n */\nexport function evaluateSetAccessorDeclaration(options: IEvaluatorOptions<TS.SetAccessorDeclaration>, parent: IndexLiteral): void {\n\tconst {node, environment, evaluate, statementTraversalStack, reporting, typescript} = options;\n\n\tconst nameResult = evaluate.nodeWithValue(node.name, environment, statementTraversalStack) as IndexLiteralKey;\n\tconst isStatic = inStaticContext(node, typescript);\n\n\t/**\n\t * An implementation of the set accessor\n\t */\n\tfunction setAccessorDeclaration(this: Literal, ...args: Literal[]) {\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\t// eslint-disable-next-line prefer-rest-params\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\tsetInLexicalEnvironment({\n\t\t\t\tenv: localLexicalEnvironment,\n\t\t\t\tpath: SUPER_SYMBOL,\n\t\t\t\tvalue: isStatic ? Object.getPrototypeOf(this) : Object.getPrototypeOf((this as CallableFunction).constructor).prototype,\n\t\t\t\tnewBinding: true,\n\t\t\t\treporting,\n\t\t\t\tnode\n\t\t\t});\n\t\t}\n\n\t\t// Evaluate the parameters based on the given arguments\n\t\tevaluateParameterDeclarations(\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tnode: node.parameters,\n\t\t\t\tenvironment: localLexicalEnvironment\n\t\t\t},\n\t\t\targs\n\t\t);\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\t}\n\n\tsetAccessorDeclaration.toString = () => `[Set: ${nameResult}]`;\n\n\tlet currentPropertyDescriptor = Object.getOwnPropertyDescriptor(parent, nameResult);\n\tif (currentPropertyDescriptor == null) currentPropertyDescriptor = {};\n\n\tObject.defineProperty(parent, nameResult, {\n\t\t...currentPropertyDescriptor,\n\t\tconfigurable: true,\n\t\tset: setAccessorDeclaration\n\t});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, IndexLiteralKey} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyAssignment, before applying it on the given parent\n */\nexport function evaluatePropertyAssignment({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.PropertyAssignment>, parent: IndexLiteral): void {\n\tconst initializer = evaluate.expression(node.initializer, environment, statementTraversalStack);\n\t// Compute the property name\n\tconst propertyNameResult = evaluate.nodeWithValue(node.name, environment, statementTraversalStack) as IndexLiteralKey;\n\n\tparent[propertyNameResult] = initializer;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ParameterDeclaration\n */\nexport function evaluateParameterDeclaration(\n\t{node, environment, evaluate, statementTraversalStack, logger}: IEvaluatorOptions<TS.ParameterDeclaration>,\n\tboundArgument: Literal\n): void {\n\t// Use the bound argument if it is given unless it is nullable and the node itself has an initializer\n\tconst boundValue = boundArgument != null || node.initializer === undefined ? boundArgument : evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\tlogger.logBinding(node.name.getText(), boundValue, \"evaluateParameterDeclaration\");\n\tevaluate.nodeWithArgument(node.name, environment, boundValue, statementTraversalStack);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {UndefinedIdentifierError} from \"../error/undefined-identifier-error/undefined-identifier-error\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a ShorthandPropertyAssignment, before applying it on the given parent\n */\nexport function evaluateShorthandPropertyAssignment({environment, node}: IEvaluatorOptions<TS.ShorthandPropertyAssignment>, parent: IndexLiteral): void {\n\tconst identifier = node.name.text;\n\tconst match = getFromLexicalEnvironment(node, environment, identifier);\n\n\tif (match == null) {\n\t\tthrow new UndefinedIdentifierError({node: node.name});\n\t}\n\n\tparent[identifier] = match.literal;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a SpreadAssignment, before applying it on the given parent\n */\nexport function evaluateSpreadAssignment({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.SpreadAssignment>, parent: IndexLiteral): void {\n\tconst entries = evaluate.expression(node.expression, environment, statementTraversalStack) as IndexLiteral;\n\tObject.assign(parent, entries);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an ArrayBindingPattern, based on an initializer\n */\nexport function evaluateArrayBindingPattern(\n\t{node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<TS.ArrayBindingPattern>,\n\trightHandValue: Iterable<Literal>\n): void {\n\tconst iterator = rightHandValue[Symbol.iterator]();\n\tlet elementsCursor = 0;\n\n\twhile (elementsCursor < node.elements.length) {\n\t\tconst {done, value} = iterator.next();\n\t\tif (done === true) break;\n\n\t\tevaluate.nodeWithArgument(node.elements[elementsCursor++], environment, value, statementTraversalStack);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a BindingName, based on an BindingElement\n */\nexport function evaluateBindingElement(\n\t{environment, node, evaluate, logger, reporting, typescript, statementTraversalStack}: IEvaluatorOptions<TS.BindingElement>,\n\trightHandValue: Literal\n): void {\n\t// Compute the initializer value of the BindingElement, if it has any, that is\n\tconst bindingElementInitializer = node.initializer == null ? undefined : evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\t// If the element is directly references a property, but then aliases, store that alias in the environment.\n\tif ((typescript.isIdentifier(node.name) || typescript.isPrivateIdentifier?.(node.name)) && node.propertyName != null) {\n\t\t// An element that is aliased cannot have a name that is anything other than an Identifier\n\t\tconst aliasName = node.name.text;\n\n\t\t// Compute the property name\n\t\tconst propertyNameResult = evaluate.nodeWithValue(node.propertyName, environment, statementTraversalStack) as IndexLiteralKey;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = typescript.isArrayBindingPattern(node.parent) ? rightHandValue : (rightHandValue as IndexLiteral)[propertyNameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null ? propertyValue : bindingElementInitializer;\n\n\t\tsetInLexicalEnvironment({\n\t\t\tenv: environment,\n\t\t\tpath: aliasName,\n\t\t\tvalue: propertyValueWithInitializerFallback,\n\t\t\tnewBinding: true,\n\t\t\tnode,\n\t\t\treporting\n\t\t});\n\t}\n\n\t// If the name is a simple non-aliased identifier, it directly references, a property from the right-hand value\n\telse if ((typescript.isIdentifier(node.name) || typescript.isPrivateIdentifier?.(node.name)) && node.propertyName == null) {\n\t\t// Compute the literal value of the name of the node\n\t\tconst nameResult = node.name.text;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = typescript.isArrayBindingPattern(node.parent) ? rightHandValue : (rightHandValue as IndexLiteral)[nameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null ? propertyValue : bindingElementInitializer;\n\n\t\tlogger.logBinding(node.name.text, propertyValueWithInitializerFallback);\n\n\t\tsetInLexicalEnvironment({\n\t\t\tenv: environment,\n\t\t\tpath: node.name.text,\n\t\t\tvalue: propertyValueWithInitializerFallback,\n\t\t\tnewBinding: true,\n\t\t\tnode,\n\t\t\treporting\n\t\t});\n\t}\n\n\t// Otherwise, the name is itself a BindingPattern, and the property it is destructuring will always be defined\n\telse if (!typescript.isIdentifier(node.name) && !typescript.isPrivateIdentifier?.(node.name) && node.propertyName != null) {\n\t\t// Compute the property name\n\t\tconst propertyNameResult = evaluate.nodeWithValue(node.propertyName, environment, statementTraversalStack) as IndexLiteralKey;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = typescript.isArrayBindingPattern(node.parent) ? rightHandValue : (rightHandValue as IndexLiteral)[propertyNameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null ? propertyValue : bindingElementInitializer;\n\n\t\t// Evaluate the BindingPattern based on the narrowed property value\n\t\tevaluate.nodeWithArgument(node.name, environment, propertyValueWithInitializerFallback, statementTraversalStack);\n\t}\n\n\t// Otherwise, the name itself is a BindingPattern. This will happen for example if an ObjectBindingPattern occurs within an ArrayBindingPattern\n\telse if (!typescript.isIdentifier(node.name) && !typescript.isPrivateIdentifier?.(node.name) && node.propertyName == null) {\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = rightHandValue != null ? rightHandValue : bindingElementInitializer;\n\n\t\tevaluate.nodeWithArgument(node.name, environment, propertyValueWithInitializerFallback, statementTraversalStack);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an ObjectBindingPattern, based on an initializer\n */\nexport function evaluateObjectBindingPattern({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TS.ObjectBindingPattern>, rightHandValue: Literal): void {\n\tfor (const element of node.elements) {\n\t\tevaluate.nodeWithArgument(element, environment, rightHandValue, statementTraversalStack);\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a CaseBlock, based on a switch expression\n */\nexport function evaluateCaseBlock({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<TS.CaseBlock>, switchExpression: Literal): void {\n\t// Prepare a lexical environment for the case block\n\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\t// Define a new binding for a break symbol within the environment\n\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\tfor (const clause of node.clauses) {\n\t\tevaluate.nodeWithArgument(clause, localEnvironment, switchExpression, statementTraversalStack);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a CaseClause, based on a switch expression\n */\nexport function evaluateCaseClause({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<TS.CaseClause>, switchExpression: Literal): void {\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);\n\t// Stop immediately if the expression doesn't match the switch expression\n\tif (expressionResult !== switchExpression) return;\n\n\tfor (const statement of node.statements) {\n\t\tevaluate.statement(statement, environment);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a DefaultClause, based on a switch expression\n */\nexport function evaluateDefaultClause({node, evaluate, environment}: IEvaluatorOptions<TS.DefaultClause>): void {\n\tfor (const statement of node.statements) {\n\t\tevaluate.statement(statement, environment);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a CatchClause, based on a given Error\n */\nexport function evaluateCatchClause({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<TS.CatchClause>, ex: Error): void {\n\t// If a catch binding is provided, we must provide a local lexical environment for the CatchBlock\n\tconst catchEnvironment = node.variableDeclaration == null ? environment : cloneLexicalEnvironment(environment);\n\n\t// Evaluate the catch binding, if any is provided\n\tif (node.variableDeclaration != null) {\n\t\tevaluate.nodeWithArgument(node.variableDeclaration, catchEnvironment, ex, statementTraversalStack);\n\t}\n\n\t// Evaluate the block\n\tevaluate.statement(node.block, catchEnvironment);\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a OmittedExpression\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function evaluateOmittedExpression(_options: IEvaluatorOptions<TS.OmittedExpression>): undefined {\n\treturn undefined;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, stringifyLiteral} from \"../literal/literal\";\nimport {NotCallableError} from \"../error/not-callable-error/not-callable-error\";\nimport {__decorate, __param} from \"tslib\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a Decorator\n */\nexport function evaluateDecorator(\n\t{node, environment, evaluate, stack, statementTraversalStack}: IEvaluatorOptions<TS.Decorator>,\n\t[parent, propertyName, index]: [IndexLiteral, string?, number?]\n): void {\n\tconst decoratorImplementation = evaluate.expression(node.expression, environment, statementTraversalStack);\n\n\tif (typeof decoratorImplementation !== \"function\") {\n\t\tthrow new NotCallableError({\n\t\t\tnode,\n\t\t\tvalue: decoratorImplementation,\n\t\t\tmessage: `${stringifyLiteral(decoratorImplementation)} is not a valid decorator implementation'`\n\t\t});\n\t}\n\n\tstack.push(__decorate([index != null ? __param(index, decoratorImplementation) : decoratorImplementation], parent, propertyName));\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, IndexLiteralKey} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, an EnumMember\n */\nexport function evaluateEnumMember({node, typeChecker, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<TS.EnumMember>, parent: IndexLiteral): void {\n\tconst constantValue = typeChecker.getConstantValue(node) as number | string;\n\tconst propertyName = evaluate.nodeWithValue(node.name, environment, statementTraversalStack) as IndexLiteralKey;\n\n\t// If it is a String enum, all keys will be initialized to strings\n\tif (typeof constantValue === \"string\") {\n\t\tparent[propertyName] = constantValue;\n\t} else {\n\t\tparent[(parent[propertyName] = constantValue)] = propertyName;\n\t}\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {evaluateBindingName} from \"./evaluate-binding-name\";\nimport {evaluateGetAccessorDeclaration} from \"./evaluate-get-accessor-declaration\";\nimport {evaluateSetAccessorDeclaration} from \"./evaluate-set-accessor-declaration\";\nimport {evaluatePropertyAssignment} from \"./evaluate-property-assignment\";\nimport {evaluateParameterDeclaration} from \"./evaluate-parameter-declaration\";\nimport {evaluateShorthandPropertyAssignment} from \"./evaluate-shorthand-property-assignment\";\nimport {evaluateSpreadAssignment} from \"./evaluate-spread-assignment\";\nimport {evaluateMethodDeclaration} from \"./evaluate-method-declaration\";\nimport {evaluateArrayBindingPattern} from \"./evaluate-array-binding-pattern\";\nimport {evaluateBindingElement} from \"./evaluate-binding-element\";\nimport {evaluateObjectBindingPattern} from \"./evaluate-object-binding-pattern\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {evaluateCaseBlock} from \"./evaluate-case-block\";\nimport {evaluateCaseClause} from \"./evaluate-case-clause\";\nimport {evaluateDefaultClause} from \"./evaluate-default-clause\";\nimport {evaluateVariableDeclaration} from \"./evaluate-variable-declaration\";\nimport {evaluateCatchClause} from \"./evaluate-catch-clause\";\nimport {evaluateOmittedExpression} from \"./evaluate-omitted-expression\";\nimport {evaluatePropertyDeclaration} from \"./evaluate-property-declaration\";\nimport {evaluateDecorator} from \"./evaluate-decorator\";\nimport {evaluateEnumMember} from \"./evaluate-enum-member\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates a given node with the provided argument\n */\nexport function evaluateNodeWithArgument(options: IEvaluatorOptions<TS.Node>, arg: Literal): void {\n\toptions.logger.logNode(options.node, options.typescript, \"nodeWithArgument\");\n\tconst {node, ...rest} = options;\n\n\tif (rest.typescript.isGetAccessorDeclaration(node)) {\n\t\treturn evaluateGetAccessorDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isSetAccessorDeclaration(node)) {\n\t\treturn evaluateSetAccessorDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isPropertyAssignment(node)) {\n\t\treturn evaluatePropertyAssignment({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isPropertyDeclaration(node)) {\n\t\treturn evaluatePropertyDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isParameter(node)) {\n\t\treturn evaluateParameterDeclaration({node, ...rest}, arg);\n\t} else if (rest.typescript.isEnumMember(node)) {\n\t\treturn evaluateEnumMember({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isShorthandPropertyAssignment(node)) {\n\t\treturn evaluateShorthandPropertyAssignment({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isDecorator(node)) {\n\t\treturn evaluateDecorator({node, ...rest}, arg as [IndexLiteral, string?]);\n\t} else if (rest.typescript.isSpreadAssignment(node)) {\n\t\treturn evaluateSpreadAssignment({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isMethodDeclaration(node)) {\n\t\treturn evaluateMethodDeclaration({node, ...rest}, arg as IndexLiteral);\n\t} else if (rest.typescript.isArrayBindingPattern(node)) {\n\t\treturn evaluateArrayBindingPattern({node, ...rest}, arg as Iterable<Literal>);\n\t} else if (rest.typescript.isBindingElement(node)) {\n\t\treturn evaluateBindingElement({node, ...rest}, arg);\n\t} else if (rest.typescript.isObjectBindingPattern(node)) {\n\t\treturn evaluateObjectBindingPattern({node, ...rest}, arg);\n\t} else if (rest.typescript.isVariableDeclaration(node)) {\n\t\treturn evaluateVariableDeclaration({node, ...rest}, arg);\n\t} else if (rest.typescript.isCaseBlock(node)) {\n\t\treturn evaluateCaseBlock({node, ...rest}, arg);\n\t} else if (rest.typescript.isCaseClause(node)) {\n\t\treturn evaluateCaseClause({node, ...rest}, arg);\n\t} else if (rest.typescript.isDefaultClause(node)) {\n\t\treturn evaluateDefaultClause({node, ...rest});\n\t} else if (rest.typescript.isCatchClause(node)) {\n\t\treturn evaluateCatchClause({node, ...rest}, arg as Error);\n\t} else if (rest.typescript.isBindingName(node)) {\n\t\treturn evaluateBindingName({node, ...rest}, arg);\n\t} else if (rest.typescript.isOmittedExpression(node)) {\n\t\treturn evaluateOmittedExpression({node, ...rest});\n\t}\n\n\tthrow new UnexpectedNodeError({node, typescript: rest.typescript});\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyName\n */\nexport function evaluatePropertyName({environment, node, evaluate, typescript, statementTraversalStack}: IEvaluatorOptions<TS.PropertyName>): Literal {\n\treturn (typescript.isComputedPropertyName(node)\n\t\t? evaluate.expression(node.expression, environment, statementTraversalStack)\n\t\t: typescript.isIdentifier(node) || typescript.isPrivateIdentifier?.(node)\n\t\t? node.text\n\t\t: evaluate.expression(node as TS.StringLiteral | TS.NumericLiteral, environment, statementTraversalStack)) as IndexLiteralKey;\n}\n","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {NodeWithValue} from \"./node-evaluator/node-evaluator\";\nimport {evaluatePropertyName} from \"./evaluate-property-name\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\n\n/**\n * Evaluates a given node with the provided argument\n */\nexport function evaluateNodeWithValue(options: IEvaluatorOptions<NodeWithValue>): Literal {\n\toptions.logger.logNode(options.node, options.typescript, \"nodeWithValue\");\n\tconst {node, ...rest} = options;\n\n\t// Until #37135 is resolved, isPropertyName will return false for PrivateIdentifiers (even though they are actually PropertyNames)\n\tif (options.typescript.isPropertyName(node) || options.typescript.isPrivateIdentifier(node)) {\n\t\treturn evaluatePropertyName({node, ...rest});\n\t}\n\n\tthrow new UnexpectedNodeError({node, typescript: options.typescript});\n}\n","import {ReportingOptionsSanitized} from \"../../reporting/i-reporting-options\";\nimport {EvaluationError} from \"../../error/evaluation-error/evaluation-error\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * Reports an error\n */\nexport function reportError(reporting: ReportingOptionsSanitized, error: Error, node: TS.Node): void {\n\t// Report the error if a reporter is hooked up\n\tif (reporting.reportErrors != null && !reporting.reportedErrorSet.has(error)) {\n\t\treporting.reportedErrorSet.add(error);\n\t\treporting.reportErrors({\n\t\t\terror: error,\n\t\t\tnode: error instanceof EvaluationError ? error.node : node\n\t\t});\n\t}\n}\n","import {ICreateNodeEvaluatorOptions} from \"./i-create-node-evaluator-options\";\nimport {NodeEvaluator, NodeWithValue} from \"./node-evaluator\";\nimport {MaxOpsExceededError} from \"../../error/policy-error/max-ops-exceeded-error/max-ops-exceeded-error\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals} from \"../../lexical-environment/lexical-environment\";\nimport {evaluateStatement} from \"../evaluate-statement\";\nimport {Literal} from \"../../literal/literal\";\nimport {evaluateExpression} from \"../evaluate-expression\";\nimport {IEvaluatorOptions} from \"../i-evaluator-options\";\nimport {evaluateDeclaration} from \"../evaluate-declaration\";\nimport {evaluateNodeWithArgument} from \"../evaluate-node-with-argument\";\nimport {evaluateNodeWithValue} from \"../evaluate-node-with-value\";\nimport {createStatementTraversalStack, StatementTraversalStack} from \"../../stack/traversal-stack/statement-traversal-stack\";\nimport {reportError} from \"../../util/reporting/report-error\";\nimport {TRY_SYMBOL} from \"../../util/try/try-symbol\";\nimport {TS} from \"../../../type/ts\";\n\n/**\n * Creates a Node Evaluator\n */\nexport function createNodeEvaluator({typeChecker, typescript, policy, logger, stack, reporting, nextNode}: ICreateNodeEvaluatorOptions): NodeEvaluator {\n\tlet ops = 0;\n\n\tconst handleNewNode = (node: TS.Node, statementTraversalStack: StatementTraversalStack) => {\n\t\tnextNode(node);\n\n\t\t// Increment the amount of encountered ops\n\t\tops++;\n\n\t\t// Throw an error if the maximum amount of operations has been exceeded\n\t\tif (ops >= policy.maxOps) {\n\t\t\tthrow new MaxOpsExceededError({ops, node});\n\t\t}\n\n\t\t// Update the statementTraversalStack with the node's kind\n\t\tstatementTraversalStack.push(node.kind);\n\t\tif (reporting.reportTraversal != null) {\n\t\t\treporting.reportTraversal({node});\n\t\t}\n\t};\n\n\t/**\n\t * Wraps an evaluation action with error reporting\n\t */\n\tconst wrapWithErrorReporting = (environment: LexicalEnvironment, node: TS.Node, action: CallableFunction) => {\n\t\t// If we're already inside of a try-block, simply execute the action and do nothing else\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, TRY_SYMBOL)) {\n\t\t\treturn action();\n\t\t}\n\n\t\ttry {\n\t\t\treturn action();\n\t\t} catch (ex) {\n\t\t\t// Report the Error\n\t\t\treportError(reporting, ex, node);\n\n\t\t\t// Re-throw the error\n\t\t\tthrow ex;\n\t\t}\n\t};\n\n\tconst nodeEvaluator: NodeEvaluator = {\n\t\texpression: (node: TS.Expression | TS.PrivateIdentifier, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): Literal =>\n\t\t\twrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateExpression(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t}),\n\t\tstatement: (node: TS.Statement, environment: LexicalEnvironment): void =>\n\t\t\twrapWithErrorReporting(environment, node, () => {\n\t\t\t\tconst statementTraversalStack = createStatementTraversalStack();\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateStatement(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t}),\n\t\tdeclaration: (node: TS.Declaration, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): void =>\n\t\t\twrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateDeclaration(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t}),\n\t\tnodeWithArgument: (node: TS.Node, environment: LexicalEnvironment, arg: Literal, statementTraversalStack: StatementTraversalStack): void =>\n\t\t\twrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateNodeWithArgument(getEvaluatorOptions(node, environment, statementTraversalStack), arg);\n\t\t\t}),\n\t\tnodeWithValue: (node: NodeWithValue, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): Literal =>\n\t\t\twrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateNodeWithValue(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t})\n\t};\n\n\t/**\n\t * Gets an IEvaluatorOptions object ready for passing to one of the evaluation functions\n\t */\n\tfunction getEvaluatorOptions<T extends TS.Node>(node: T, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): IEvaluatorOptions<T> {\n\t\treturn {\n\t\t\ttypeChecker,\n\t\t\ttypescript,\n\t\t\tpolicy,\n\t\t\treporting,\n\t\t\tnode,\n\t\t\tevaluate: nodeEvaluator,\n\t\t\tenvironment,\n\t\t\tstack,\n\t\t\tlogger,\n\t\t\tstatementTraversalStack\n\t\t};\n\t}\n\n\treturn nodeEvaluator;\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Stringifies the given SyntaxKind\n */\nexport function stringifySyntaxKind(kind: TS.SyntaxKind, typescript: typeof TS): string {\n\tif (kind === typescript.SyntaxKind.NumericLiteral) return \"NumericLiteral\";\n\treturn typescript.SyntaxKind[kind];\n}\n","import {LogLevelKind} from \"./log-level\";\nimport chalk from \"chalk\";\nimport {stringifySyntaxKind} from \"../util/syntax-kind/stringify-syntax-kind\";\nimport {Literal, stringifyLiteral} from \"../literal/literal\";\nimport {Stack} from \"../stack/stack\";\nimport {StatementTraversalStack} from \"../stack/traversal-stack/statement-traversal-stack\";\nimport {inspect} from \"util\";\nimport {TS} from \"../../type/ts\";\n\n/**\n * A simple logger for printing evaluation-related info\n */\nexport class Logger {\n\tconstructor(readonly logLevel: LogLevelKind) {}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs info output if the log level allows it\n\t */\n\tlogInfo(message: string): void {\n\t\tif (this.logLevel < LogLevelKind.INFO) return;\n\t\tconsole.log(message);\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs verbose output if the log level allows it\n\t */\n\tlogVerbose(message: string): void {\n\t\tif (this.logLevel < LogLevelKind.VERBOSE) return;\n\t\tconsole.log(message);\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs debug output if the log level allows it\n\t */\n\tlogDebug(message: string): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(message);\n\t}\n\n\t/**\n\t * Logs that a 'continue' keyword appeared within a statement\n\t */\n\tlogContinue(node: TS.Node, typescript: typeof TS): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`${chalk.yellow(`continue`)} encountered within ${chalk.yellow(stringifySyntaxKind(node.kind, typescript))}`);\n\t}\n\n\t/**\n\t * Logs that a 'break' keyword appeared within a statement\n\t */\n\tlogBreak(node: TS.Node, typescript: typeof TS): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`${chalk.yellow(`break`)} encountered within ${chalk.yellow(stringifySyntaxKind(node.kind, typescript))}`);\n\t}\n\n\t/**\n\t * Logs that a 'return' keyword appeared within a statement\n\t */\n\tlogReturn(node: TS.Node, typescript: typeof TS): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`${chalk.yellow(`return`)} encountered within ${chalk.yellow(stringifySyntaxKind(node.kind, typescript))}`);\n\t}\n\n\t/**\n\t * Logs the given result\n\t */\n\tlogResult(result: Literal, intermediateContext?: string): void {\n\t\tif (this.logLevel < LogLevelKind.INFO) return;\n\t\tif (intermediateContext != null) {\n\t\t\tconsole.log(chalk.gray(`(intermediate value from context '${intermediateContext}'): `), chalk.green(`[RESULT]:`), this.compactValue(result));\n\t\t} else console.log(chalk.green(`[RESULT]:`), result);\n\t}\n\n\t/**\n\t * Logs the given evaluation\n\t */\n\tlogNode(node: TS.Node, typescript: typeof TS, context?: string): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\n\t\tlet headRaw = `[${stringifySyntaxKind(node.kind, typescript)}]`.padEnd(25);\n\t\tif (context != null) headRaw += chalk.cyan(`(${context})`);\n\t\tconst tailRaw = node.getText();\n\n\t\tconst head = chalk.yellow(headRaw);\n\t\tconst tail = chalk.gray(tailRaw);\n\n\t\tconsole.log(head);\n\t\tconsole.log(tail);\n\t}\n\n\t/**\n\t * Logs the given binding\n\t */\n\tlogBinding(lValue: string, rValue: Literal, scope?: string): void {\n\t\tif (this.logLevel < LogLevelKind.VERBOSE) return;\n\t\tconsole.log(`${scope == null ? \"\" : chalk.green(`(${scope}): `)}${chalk.red(lValue)} ->`, this.compactValue(rValue));\n\t}\n\n\t/**\n\t * Logs the heritage of a ClassDeclaration\n\t */\n\tlogHeritage(classDeclaration: CallableFunction): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconst parent = Object.getPrototypeOf(classDeclaration);\n\t\t// eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n\t\tif (parent.toString().includes(\"[Class\")) {\n\t\t\tconsole.log(`${chalk.cyan(classDeclaration.toString())} ${chalk.yellow(\"extends\")} ${chalk.cyan(parent.toString())}`);\n\t\t}\n\t}\n\n\t/**\n\t * Logs the newest value has been pushed onto the Stack\n\t */\n\tlogStack(stack: Stack): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`Stack value: ${chalk.blue(stringifyLiteral(this.compactValue(stack.lastItem)))}`);\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs the entire Traversal Stack\n\t */\n\tlogStatementTraversalStack(stack: StatementTraversalStack, typescript: typeof TS): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`[${stack.map(kind => chalk.blue(stringifySyntaxKind(kind, typescript))).join(\", \")}]`);\n\t}\n\n\t/**\n\t * Makes a value compact so it is easier on the eyes when printing it\n\t */\n\tprivate compactValue<T>(value: T): string {\n\t\treturn inspect(value, {depth: 0, colors: true, compact: true, maxArrayLength: 5});\n\t}\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given Node is an Expression.\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n */\nexport function isExpression(node: TS.Node, typescript: typeof TS): node is TS.Expression {\n\treturn ((typescript as unknown) as {isExpressionNode(node: TS.Node): boolean}).isExpressionNode(node) || typescript.isIdentifier(node) || typescript.isPrivateIdentifier?.(node);\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given Node is a Statement\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n */\nexport function isStatement(node: TS.Node, typescript: typeof TS): node is TS.Statement {\n\treturn ((typescript as unknown) as {isStatementButNotDeclaration(node: TS.Node): boolean}).isStatementButNotDeclaration(node);\n}\n","import {Literal} from \"../literal/literal\";\n\nexport interface Stack {\n\treadonly length: number;\n\treadonly lastItem: StackEntry | undefined;\n\t[Symbol.iterator](): IterableIterator<StackEntry>;\n\tpush(...values: StackEntry[]): number;\n\tpop(): StackEntry | undefined;\n}\n\nexport type StackEntry = Literal;\n\n/**\n * Creates a Stack\n *\n * @return\n */\nexport function createStack(): Stack {\n\tconst stack: StackEntry[] = [];\n\n\treturn {\n\t\t/**\n\t\t * Gets an iterator for the Stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\t[Symbol.iterator]() {\n\t\t\treturn stack[Symbol.iterator]();\n\t\t},\n\n\t\t/**\n\t\t * Gets the length of the Stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\tget length() {\n\t\t\treturn stack.length;\n\t\t},\n\n\t\t/**\n\t\t * Gets the last item of the Stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\tget lastItem() {\n\t\t\treturn stack[stack.length - 1];\n\t\t},\n\n\t\t/**\n\t\t * Pushes the given StackEntries on to the Stack\n\t\t *\n\t\t * @param values\n\t\t * @return\n\t\t */\n\t\tpush(...values: StackEntry[]) {\n\t\t\treturn stack.push(...values);\n\t\t},\n\n\t\t/**\n\t\t * Pops the last item from the stack\n\t\t *\n\t\t * @return\n\t\t */\n\t\tpop() {\n\t\t\treturn stack.pop();\n\t\t}\n\t};\n}\n","import {TS} from \"../../../type/ts\";\n\n/**\n * Returns true if the given Node is a Declaration\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n */\nexport function isDeclaration(node: TS.Node, typescript: typeof TS): node is TS.Declaration {\n\treturn ((typescript as unknown) as {isDeclaration(node: TS.Node): boolean}).isDeclaration(node);\n}\n","export type ReportedErrorSet = WeakSet<Error>;\n\n/**\n * Creates and returns a Set of Errors that has been seen and has been reported\n */\nexport function createReportedErrorSet(): ReportedErrorSet {\n\treturn new WeakSet<Error>();\n}\n","import * as TSModule from \"typescript\";\nimport {IEvaluateOptions} from \"./i-evaluate-options\";\nimport {createLexicalEnvironment} from \"./lexical-environment/lexical-environment\";\nimport {EvaluateResult} from \"./evaluate-result\";\nimport {evaluateSimpleLiteral} from \"./evaluator/simple/evaluate-simple-literal\";\nimport {createNodeEvaluator} from \"./evaluator/node-evaluator/create-node-evaluator\";\nimport {LogLevelKind} from \"./logger/log-level\";\nimport {Logger} from \"./logger/logger\";\nimport {createStatementTraversalStack} from \"./stack/traversal-stack/statement-traversal-stack\";\nimport {isExpression} from \"./util/expression/is-expression\";\nimport {Literal} from \"./literal/literal\";\nimport {isStatement} from \"./util/statement/is-statement\";\nimport {createStack, Stack} from \"./stack/stack\";\nimport {isDeclaration} from \"./util/declaration/is-declaration\";\nimport {UnexpectedNodeError} from \"./error/unexpected-node-error/unexpected-node-error\";\nimport {IEvaluatePolicySanitized} from \"./policy/i-evaluate-policy\";\nimport {EnvironmentPresetKind} from \"./environment/environment-preset-kind\";\nimport {reportError} from \"./util/reporting/report-error\";\nimport {createReportedErrorSet} from \"./reporting/reported-error-set\";\nimport {ReportingOptionsSanitized} from \"./reporting/i-reporting-options\";\nimport {TS} from \"../type/ts\";\n\n/**\n * Will get a literal value for the given Expression, ExpressionStatement, or Declaration.\n */\nexport function evaluate({\n\ttypeChecker,\n\tnode,\n\tenvironment: {preset = EnvironmentPresetKind.NODE, extra = {}} = {},\n\ttypescript = TSModule,\n\tlogLevel = LogLevelKind.SILENT,\n\tpolicy: {\n\t\tdeterministic = false,\n\t\tnetwork = false,\n\t\tconsole = false,\n\t\tmaxOps = Infinity,\n\t\tmaxOpDuration = Infinity,\n\t\tio = {\n\t\t\tread: true,\n\t\t\twrite: false\n\t\t},\n\t\tprocess = {\n\t\t\texit: false,\n\t\t\tspawnChild: false\n\t\t}\n\t} = {},\n\treporting: reportingInput = {}\n}: IEvaluateOptions): EvaluateResult {\n\t// Take the simple path first. This may be far more performant than building up an environment\n\tconst simpleLiteralResult = evaluateSimpleLiteral(node, typescript);\n\tif (simpleLiteralResult.success) return simpleLiteralResult;\n\n\t// Otherwise, build an environment and get to work\n\t// Sanitize the evaluation policy based on the input options\n\tconst policy: IEvaluatePolicySanitized = {\n\t\tdeterministic,\n\t\tmaxOps,\n\t\tmaxOpDuration,\n\t\tnetwork,\n\t\tconsole,\n\t\tio: {\n\t\t\tread: typeof io === \"boolean\" ? io : io.read,\n\t\t\twrite: typeof io === \"boolean\" ? io : io.write\n\t\t},\n\t\tprocess: {\n\t\t\texit: typeof process === \"boolean\" ? process : process.exit,\n\t\t\tspawnChild: typeof process === \"boolean\" ? process : process.spawnChild\n\t\t}\n\t};\n\n\t// Sanitize the Reporting options based on the input options\n\tconst reporting: ReportingOptionsSanitized = {\n\t\t...reportingInput,\n\t\treportedErrorSet: createReportedErrorSet()\n\t};\n\n\t// Prepare a reference to the Node that is currently being evaluated\n\tlet currentNode: TS.Node = node;\n\n\t// Prepare a logger\n\tconst logger = new Logger(logLevel);\n\n\t// Prepare the initial environment\n\tconst initialEnvironment = createLexicalEnvironment({\n\t\tinputEnvironment: {\n\t\t\tpreset,\n\t\t\textra\n\t\t},\n\t\tpolicy,\n\t\tgetCurrentNode: () => currentNode\n\t});\n\n\t// Prepare a Stack\n\tconst stack: Stack = createStack();\n\n\t// Prepare a NodeEvaluator\n\tconst nodeEvaluator = createNodeEvaluator({\n\t\tpolicy,\n\t\ttypeChecker,\n\t\ttypescript,\n\t\tlogger,\n\t\tstack,\n\t\treporting: reporting,\n\t\tnextNode: nextNode => (currentNode = nextNode)\n\t});\n\n\ttry {\n\t\tlet value: Literal;\n\t\tif (isExpression(node, typescript)) {\n\t\t\tvalue = nodeEvaluator.expression(node, initialEnvironment, createStatementTraversalStack());\n\t\t} else if (isStatement(node, typescript)) {\n\t\t\tnodeEvaluator.statement(node, initialEnvironment);\n\t\t\tvalue = stack.pop();\n\t\t} else if (isDeclaration(node, typescript)) {\n\t\t\tnodeEvaluator.declaration(node, initialEnvironment, createStatementTraversalStack());\n\t\t\tvalue = stack.pop();\n\t\t}\n\n\t\t// Otherwise, throw an UnexpectedNodeError\n\t\telse {\n\t\t\t// noinspection ExceptionCaughtLocallyJS\n\t\t\tthrow new UnexpectedNodeError({node, typescript});\n\t\t}\n\n\t\t// Log the value before returning\n\t\tlogger.logResult(value);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tvalue\n\t\t};\n\t} catch (reason) {\n\t\t// Report the Error\n\t\treportError(reporting, reason, node);\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\treason\n\t\t};\n\t}\n}\n"],"names":["dirname","EnvironmentPresetKind","JSDOM","has","get","set","del","__decorate","__param","chalk","inspect","TSModule"],"mappings":"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"}