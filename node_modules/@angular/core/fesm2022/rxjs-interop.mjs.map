{"version":3,"file":"rxjs-interop.mjs","sources":["../../../../../../packages/core/rxjs-interop/src/take_until_destroyed.ts","../../../../../../packages/core/rxjs-interop/src/to_observable.ts","../../../../../../packages/core/src/error_details_base_url.ts","../../../../../../packages/core/src/errors.ts","../../../../../../packages/core/src/signals/src/api.ts","../../../../../../packages/core/src/util/global.ts","../../../../../../packages/core/src/util/ng_dev_mode.ts","../../../../../../packages/core/src/signals/src/graph.ts","../../../../../../packages/core/src/signals/src/computed.ts","../../../../../../packages/core/src/signals/src/errors.ts","../../../../../../packages/core/src/signals/src/signal.ts","../../../../../../packages/core/src/signals/src/untracked.ts","../../../../../../packages/core/src/signals/src/watch.ts","../../../../../../packages/core/src/signals/src/weak_ref.ts","../../../../../../packages/core/rxjs-interop/src/to_signal.ts","../../../../../../packages/core/rxjs-interop/rxjs-interop.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, DestroyRef, inject} from '@angular/core';\nimport {MonoTypeOperatorFunction, Observable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nexport function takeUntilDestroyed<T>(destroyRef?: DestroyRef): MonoTypeOperatorFunction<T> {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n\n  const destroyed$ = new Observable<void>(observer => {\n    const unregisterFn = destroyRef!.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n\n  return <T>(source: Observable<T>) => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, DestroyRef, effect, EffectRef, inject, Injector, Signal, untracked} from '@angular/core';\nimport {Observable, ReplaySubject} from 'rxjs';\n\n/**\n * Options for `toObservable`.\n *\n * @developerPreview\n */\nexport interface ToObservableOptions {\n  /**\n   * The `Injector` to use when creating the underlying `effect` which watches the signal.\n   *\n   * If this isn't specified, the current [injection context](guide/dependency-injection-context)\n   * will be used.\n   */\n  injector?: Injector;\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nexport function toObservable<T>(\n    source: Signal<T>,\n    options?: ToObservableOptions,\n    ): Observable<T> {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject<T>(1);\n\n  const watcher = effect(() => {\n    let value: T;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {injector, manualCleanup: true});\n\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n\n  return subject.asObservable();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nexport const ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n\n/**\n * URL for the XSS security documentation.\n */\nexport const XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_DETAILS_PAGE_BASE_URL} from './error_details_base_url';\n\n/**\n * The list of error codes used in runtime code of the `core` package.\n * Reserved error code range: 100-999.\n *\n * Note: the minus sign denotes the fact that a particular code has a detailed guide on\n * angular.io. This extra annotation is needed to avoid introducing a separate set to store\n * error codes which have guides, which might leak into runtime code.\n *\n * Full list of available error guides can be found at https://angular.io/errors.\n *\n * Error code ranges per package:\n *  - core (this package): 100-999\n *  - forms: 1000-1999\n *  - common: 2000-2999\n *  - animations: 3000-3999\n *  - router: 4000-4999\n *  - platform-browser: 5000-5500\n */\nexport const enum RuntimeErrorCode {\n  // Change Detection Errors\n  EXPRESSION_CHANGED_AFTER_CHECKED = -100,\n  RECURSIVE_APPLICATION_REF_TICK = 101,\n  RECURSIVE_APPLICATION_RENDER = 102,\n\n  // Dependency Injection Errors\n  CYCLIC_DI_DEPENDENCY = -200,\n  PROVIDER_NOT_FOUND = -201,\n  INVALID_FACTORY_DEPENDENCY = 202,\n  MISSING_INJECTION_CONTEXT = -203,\n  INVALID_INJECTION_TOKEN = 204,\n  INJECTOR_ALREADY_DESTROYED = 205,\n  PROVIDER_IN_WRONG_CONTEXT = 207,\n  MISSING_INJECTION_TOKEN = 208,\n  INVALID_MULTI_PROVIDER = -209,\n  MISSING_DOCUMENT = 210,\n\n  // Template Errors\n  MULTIPLE_COMPONENTS_MATCH = -300,\n  EXPORT_NOT_FOUND = -301,\n  PIPE_NOT_FOUND = -302,\n  UNKNOWN_BINDING = 303,\n  UNKNOWN_ELEMENT = 304,\n  TEMPLATE_STRUCTURE_ERROR = 305,\n  INVALID_EVENT_BINDING = 306,\n  HOST_DIRECTIVE_UNRESOLVABLE = 307,\n  HOST_DIRECTIVE_NOT_STANDALONE = 308,\n  DUPLICATE_DIRECTITVE = 309,\n  HOST_DIRECTIVE_COMPONENT = 310,\n  HOST_DIRECTIVE_UNDEFINED_BINDING = 311,\n  HOST_DIRECTIVE_CONFLICTING_ALIAS = 312,\n  MULTIPLE_MATCHING_PIPES = 313,\n\n  // Bootstrap Errors\n  MULTIPLE_PLATFORMS = 400,\n  PLATFORM_NOT_FOUND = 401,\n  MISSING_REQUIRED_INJECTABLE_IN_BOOTSTRAP = 402,\n  BOOTSTRAP_COMPONENTS_NOT_FOUND = -403,\n  PLATFORM_ALREADY_DESTROYED = 404,\n  ASYNC_INITIALIZERS_STILL_RUNNING = 405,\n  APPLICATION_REF_ALREADY_DESTROYED = 406,\n  RENDERER_NOT_FOUND = 407,\n\n  // Hydration Errors\n  HYDRATION_NODE_MISMATCH = -500,\n  HYDRATION_MISSING_SIBLINGS = -501,\n  HYDRATION_MISSING_NODE = -502,\n  UNSUPPORTED_PROJECTION_DOM_NODES = -503,\n  INVALID_SKIP_HYDRATION_HOST = -504,\n  MISSING_HYDRATION_ANNOTATIONS = -505,\n  HYDRATION_STABLE_TIMEDOUT = -506,\n  MISSING_SSR_CONTENT_INTEGRITY_MARKER = -507,\n\n  // Signal Errors\n  SIGNAL_WRITE_FROM_ILLEGAL_CONTEXT = 600,\n  REQUIRE_SYNC_WITHOUT_SYNC_EMIT = 601,\n\n  // Styling Errors\n\n  // Declarations Errors\n\n  // i18n Errors\n  INVALID_I18N_STRUCTURE = 700,\n  MISSING_LOCALE_DATA = 701,\n\n  // standalone errors\n  IMPORT_PROVIDERS_FROM_STANDALONE = 800,\n\n  // JIT Compilation Errors\n  // Other\n  INVALID_DIFFER_INPUT = 900,\n  NO_SUPPORTING_DIFFER_FACTORY = 901,\n  VIEW_ALREADY_ATTACHED = 902,\n  INVALID_INHERITANCE = 903,\n  UNSAFE_VALUE_IN_RESOURCE_URL = 904,\n  UNSAFE_VALUE_IN_SCRIPT = 905,\n  MISSING_GENERATED_DEF = 906,\n  TYPE_IS_NOT_STANDALONE = 907,\n  MISSING_ZONEJS = 908,\n  UNEXPECTED_ZONE_STATE = 909,\n  UNSAFE_IFRAME_ATTRS = -910,\n  VIEW_ALREADY_DESTROYED = 911,\n  COMPONENT_ID_COLLISION = -912,\n\n  // Runtime dependency tracker errors\n  RUNTIME_DEPS_INVALID_IMPORTED_TYPE = 1000,\n}\n\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nexport class RuntimeError<T extends number = RuntimeErrorCode> extends Error {\n  constructor(public code: T, message: null|false|string) {\n    super(formatRuntimeError<T>(code, message));\n  }\n}\n\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nexport function formatRuntimeError<T extends number = RuntimeErrorCode>(\n    code: T, message: null|false|string): string {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage =\n        `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nexport const SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\n\n/**\n * A reactive value which notifies consumers of any changes.\n *\n * Signals are functions which returns their current value. To access the current value of a signal,\n * call it.\n *\n * Ordinary values can be turned into `Signal`s with the `signal` function.\n *\n * @developerPreview\n */\nexport type Signal<T> = (() => T)&{\n  [SIGNAL]: unknown;\n};\n\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nexport function isSignal(value: unknown): value is Signal<unknown> {\n  return typeof value === 'function' && (value as Signal<unknown>)[SIGNAL] !== undefined;\n}\n\n/**\n * A comparison function which can determine if two values are equal.\n *\n * @developerPreview\n */\nexport type ValueEqualityFn<T> = (a: T, b: T) => boolean;\n\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nexport function defaultEquals<T>(a: T, b: T) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst _global: any = globalThis;\n\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from './global';\n\ndeclare global {\n  /**\n   * Values of ngDevMode\n   * Depending on the current state of the application, ngDevMode may have one of several values.\n   *\n   * For convenience, the “truthy” value which enables dev mode is also an object which contains\n   * Angular’s performance counters. This is not necessary, but cuts down on boilerplate for the\n   * perf counters.\n   *\n   * ngDevMode may also be set to false. This can happen in one of a few ways:\n   * - The user explicitly sets `window.ngDevMode = false` somewhere in their app.\n   * - The user calls `enableProdMode()`.\n   * - The URL contains a `ngDevMode=false` text.\n   * Finally, ngDevMode may not have been defined at all.\n   */\n  const ngDevMode: null|NgDevModePerfCounters;\n\n  interface NgDevModePerfCounters {\n    namedConstructors: boolean;\n    firstCreatePass: number;\n    tNode: number;\n    tView: number;\n    rendererCreateTextNode: number;\n    rendererSetText: number;\n    rendererCreateElement: number;\n    rendererAddEventListener: number;\n    rendererSetAttribute: number;\n    rendererRemoveAttribute: number;\n    rendererSetProperty: number;\n    rendererSetClassName: number;\n    rendererAddClass: number;\n    rendererRemoveClass: number;\n    rendererSetStyle: number;\n    rendererRemoveStyle: number;\n    rendererDestroy: number;\n    rendererDestroyNode: number;\n    rendererMoveNode: number;\n    rendererRemoveNode: number;\n    rendererAppendChild: number;\n    rendererInsertBefore: number;\n    rendererCreateComment: number;\n    hydratedNodes: number;\n    hydratedComponents: number;\n    dehydratedViewsRemoved: number;\n    dehydratedViewsCleanupRuns: number;\n    componentsSkippedHydration: number;\n  }\n}\n\nexport function ngDevModeResetPerfCounters(): NgDevModePerfCounters {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters: NgDevModePerfCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0,\n  };\n\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nexport function initNgDevMode(): boolean {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n// global `ngDevMode` type is defined.\nimport '../../util/ng_dev_mode';\n\ntype Version = number&{__brand: 'Version'};\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer: ReactiveNode|null = null;\nlet inNotificationPhase = false;\n\nexport function setActiveConsumer(consumer: ReactiveNode|null): ReactiveNode|null {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n};\n\n/**\n * A producer and/or consumer which participates in the reactive graph.\n *\n * Producer `ReactiveNode`s which are accessed when a consumer `ReactiveNode` is the\n * `activeConsumer` are tracked as dependencies of that consumer.\n *\n * Certain consumers are also tracked as \"live\" consumers and create edges in the other direction,\n * from producer to consumer. These edges are used to propagate change notifications when a\n * producer's value is updated.\n *\n * A `ReactiveNode` may be both a producer and consumer.\n */\nexport interface ReactiveNode {\n  /**\n   * Version of the value that this node produces.\n   *\n   * This is incremented whenever a new value is produced by this node which is not equal to the\n   * previous value (by whatever definition of equality is in use).\n   */\n  version: Version;\n\n  /**\n   * Whether this node (in its consumer capacity) is dirty.\n   *\n   * Only live consumers become dirty, when receiving a change notification from a dependency\n   * producer.\n   */\n  dirty: boolean;\n\n  /**\n   * Producers which are dependencies of this consumer.\n   *\n   * Uses the same indices as the `producerLastReadVersion` and `producerIndexOfThis` arrays.\n   */\n  producerNode: ReactiveNode[]|undefined;\n\n  /**\n   * `Version` of the value last read by a given producer.\n   *\n   * Uses the same indices as the `producerNode` and `producerIndexOfThis` arrays.\n   */\n  producerLastReadVersion: Version[]|undefined;\n\n  /**\n   * Index of `this` (consumer) in each producer's `liveConsumers` array.\n   *\n   * This value is only meaningful if this node is live (`liveConsumers.length > 0`). Otherwise\n   * these indices are stale.\n   *\n   * Uses the same indices as the `producerNode` and `producerLastReadVersion` arrays.\n   */\n  producerIndexOfThis: number[]|undefined;\n\n  /**\n   * Index into the producer arrays that the next dependency of this node as a consumer will use.\n   *\n   * This index is zeroed before this node as a consumer begins executing. When a producer is read,\n   * it gets inserted into the producers arrays at this index. There may be an existing dependency\n   * in this location which may or may not match the incoming producer, depending on whether the\n   * same producers were read in the same order as the last computation.\n   */\n  nextProducerIndex: number;\n\n  /**\n   * Array of consumers of this producer that are \"live\" (they require push notifications).\n   *\n   * `liveConsumerNode.length` is effectively our reference count for this node.\n   */\n  liveConsumerNode: ReactiveNode[]|undefined;\n\n  /**\n   * Index of `this` (producer) in each consumer's `producerNode` array.\n   *\n   * Uses the same indices as the `liveConsumerNode` array.\n   */\n  liveConsumerIndexOfThis: number[]|undefined;\n\n  /**\n   * Whether writes to signals are allowed when this consumer is the `activeConsumer`.\n   *\n   * This is used to enforce guardrails such as preventing writes to writable signals in the\n   * computation function of computed signals, which is supposed to be pure.\n   */\n  consumerAllowSignalWrites: boolean;\n\n  readonly consumerIsAlwaysLive: boolean;\n\n  /**\n   * Tracks whether producers need to recompute their value independently of the reactive graph (for\n   * example, if no initial value has been computed).\n   */\n  producerMustRecompute(node: unknown): boolean;\n  producerRecomputeValue(node: unknown): void;\n  consumerMarkedDirty(node: unknown): void;\n}\n\ninterface ConsumerNode extends ReactiveNode {\n  producerNode: NonNullable<ReactiveNode['producerNode']>;\n  producerIndexOfThis: NonNullable<ReactiveNode['producerIndexOfThis']>;\n  producerLastReadVersion: NonNullable<ReactiveNode['producerLastReadVersion']>;\n}\n\ninterface ProducerNode extends ReactiveNode {\n  liveConsumerNode: NonNullable<ReactiveNode['liveConsumerNode']>;\n  liveConsumerIndexOfThis: NonNullable<ReactiveNode['liveConsumerIndexOfThis']>;\n}\n\n/**\n * Called by implementations when a producer's signal is read.\n */\nexport function producerAccessed(node: ReactiveNode): void {\n  if (inNotificationPhase) {\n    throw new Error(\n        typeof ngDevMode !== 'undefined' && ngDevMode ?\n            `Assertion error: signal read during notification phase` :\n            '');\n  }\n\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n\n  // This producer is the `idx`th dependency of `activeConsumer`.\n  const idx = activeConsumer.nextProducerIndex++;\n\n  assertConsumerNode(activeConsumer);\n\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    // There's been a change in producers since the last execution of `activeConsumer`.\n    // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n    // replaced with `this`.\n    //\n    // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n    // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n    // to remove it from the stale producer's `liveConsumer`s.\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n\n      // At this point, the only record of `staleProducer` is the reference at\n      // `activeConsumer.producerNode[idx]` which will be overwritten below.\n    }\n  }\n\n  if (activeConsumer.producerNode[idx] !== node) {\n    // We're a new dependency of the consumer (at `idx`).\n    activeConsumer.producerNode[idx] = node;\n\n    // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n    // placeholder value.\n    activeConsumer.producerIndexOfThis[idx] =\n        consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nexport function producerUpdateValueVersion(node: ReactiveNode): void {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    node.dirty = false;\n    return;\n  }\n\n  node.producerRecomputeValue(node);\n\n  // After recomputing the value, we're no longer dirty.\n  node.dirty = false;\n}\n\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nexport function producerNotifyConsumers(node: ReactiveNode): void {\n  if (node.liveConsumerNode === undefined) {\n    return;\n  }\n\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nexport function producerUpdatesAllowed(): boolean {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\n\nexport function consumerMarkDirty(node: ReactiveNode): void {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\n\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nexport function consumerBeforeComputation(node: ReactiveNode|null): ReactiveNode|null {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nexport function consumerAfterComputation(\n    node: ReactiveNode|null, prevConsumer: ReactiveNode|null): void {\n  setActiveConsumer(prevConsumer);\n\n  if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined ||\n      node.producerLastReadVersion === undefined) {\n    return;\n  }\n\n  if (consumerIsLive(node)) {\n    // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n    // which weren't dependencies after the recomputation.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n\n  // Truncate the producer tracking arrays.\n  // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n  // benchmarking has shown that individual pop operations are faster.\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\n\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nexport function consumerPollProducersForChange(node: ReactiveNode): boolean {\n  assertConsumerNode(node);\n\n  // Poll producers for change.\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Disconnect this consumer from the graph.\n */\nexport function consumerDestroy(node: ReactiveNode): void {\n  assertConsumerNode(node);\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n\n  // Truncate all the arrays to drop all connection from this node to the graph.\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length =\n      0;\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis!.length = 0;\n  }\n}\n\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(\n    node: ReactiveNode, consumer: ReactiveNode, indexOfThis: number): number {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (node.liveConsumerNode.length === 0) {\n    // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\n\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node: ReactiveNode, idx: number): void {\n  assertProducerNode(node);\n  assertConsumerNode(node);\n\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${\n        node.liveConsumerNode.length} consumers)`);\n  }\n\n  if (node.liveConsumerNode.length === 1) {\n    // When removing the last live consumer, we will no longer be live. We need to remove\n    // ourselves from our producers' tracking (which may cause consumer-producers to lose\n    // liveness as well).\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n\n  // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n  // live consumer, this is a no-op.\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n\n  // Truncate the array.\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n\n  // If the index is still valid, then we need to fix the index pointer from the producer to this\n  // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\n\nfunction consumerIsLive(node: ReactiveNode): boolean {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\n\n\nfunction assertConsumerNode(node: ReactiveNode): asserts node is ConsumerNode {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\n\nfunction assertProducerNode(node: ReactiveNode): asserts node is ProducerNode {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {defaultEquals, SIGNAL, Signal, ValueEqualityFn} from './api';\nimport {consumerAfterComputation, consumerBeforeComputation, producerAccessed, producerUpdateValueVersion, REACTIVE_NODE, ReactiveNode} from './graph';\n\n/**\n * Options passed to the `computed` creation function.\n *\n * @developerPreview\n */\nexport interface CreateComputedOptions<T> {\n  /**\n   * A comparison function which defines equality for computed values.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nexport function computed<T>(computation: () => T, options?: CreateComputedOptions<T>): Signal<T> {\n  const node: ComputedNode<T> = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  options?.equal && (node.equal = options.equal);\n\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n\n    return node.value;\n  };\n  (computed as any)[SIGNAL] = node;\n  return computed as any as Signal<T>;\n}\n\n\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET: any = /* @__PURE__ */ Symbol('UNSET');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING: any = /* @__PURE__ */ Symbol('COMPUTING');\n\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED: any = /* @__PURE__ */ Symbol('ERRORED');\n\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\ninterface ComputedNode<T> extends ReactiveNode {\n  /**\n   * Current value of the computation, or one of the sentinel values above (`UNSET`, `COMPUTING`,\n   * `ERROR`).\n   */\n  value: T;\n\n  /**\n   * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n   * be re-thrown.\n   */\n  error: unknown;\n\n  /**\n   * The computation function which will produce a new value.\n   */\n  computation: () => T;\n\n  equal: ValueEqualityFn<T>;\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n\n    producerMustRecompute(node: ComputedNode<unknown>): boolean {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n\n    producerRecomputeValue(node: ComputedNode<unknown>): void {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n\n      const oldValue = node.value;\n      node.value = COMPUTING;\n\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue: unknown;\n      try {\n        newValue = node.computation();\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n\n      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n          node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n\n      node.value = newValue;\n      node.version++;\n    },\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nfunction defaultThrowError(): never {\n  throw new Error();\n}\n\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\n\nexport function throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\n\nexport function setThrowInvalidWriteToSignalError(fn: () => never): void {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {defaultEquals, SIGNAL, Signal, ValueEqualityFn} from './api';\nimport {throwInvalidWriteToSignalError} from './errors';\nimport {producerAccessed, producerNotifyConsumers, producerUpdatesAllowed, REACTIVE_NODE, ReactiveNode,} from './graph';\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn: (() => void)|null = null;\n\n/**\n * A `Signal` with a value that can be mutated via a setter interface.\n *\n * @developerPreview\n */\nexport interface WritableSignal<T> extends Signal<T> {\n  /**\n   * Directly set the signal to a new value, and notify any dependents.\n   */\n  set(value: T): void;\n\n  /**\n   * Update the value of the signal based on its current value, and\n   * notify any dependents.\n   */\n  update(updateFn: (value: T) => T): void;\n\n  /**\n   * Update the current value by mutating it in-place, and\n   * notify any dependents.\n   */\n  mutate(mutatorFn: (value: T) => void): void;\n\n  /**\n   * Returns a readonly version of this signal. Readonly signals can be accessed to read their value\n   * but can't be changed using set, update or mutate methods. The readonly signals do _not_ have\n   * any built-in mechanism that would prevent deep-mutation of their value.\n   */\n  asReadonly(): Signal<T>;\n}\n\n/**\n * Options passed to the `signal` creation function.\n *\n * @developerPreview\n */\nexport interface CreateSignalOptions<T> {\n  /**\n   * A comparison function which defines equality for signal values.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nexport function signal<T>(initialValue: T, options?: CreateSignalOptions<T>): WritableSignal<T> {\n  const node: SignalNode<T> = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  options?.equal && (node.equal = options.equal);\n\n  function signalFn() {\n    producerAccessed(node);\n    return node.value;\n  }\n\n  signalFn.set = signalSetFn;\n  signalFn.update = signalUpdateFn;\n  signalFn.mutate = signalMutateFn;\n  signalFn.asReadonly = signalAsReadonlyFn;\n  (signalFn as any)[SIGNAL] = node;\n\n  return signalFn as WritableSignal<T>;\n}\n\nexport function setPostSignalSetFn(fn: (() => void)|null): (() => void)|null {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\ninterface SignalNode<T> extends ReactiveNode {\n  value: T;\n  equal: ValueEqualityFn<T>;\n  readonlyFn: Signal<T>|null;\n}\n\ninterface SignalFn<T> extends Signal<T> {\n  [SIGNAL]: SignalNode<T>;\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    readonlyFn: undefined,\n  };\n})();\n\nfunction signalValueChanged<T>(node: SignalNode<T>): void {\n  node.version++;\n  producerNotifyConsumers(node);\n\n  postSignalSetFn?.();\n}\n\nfunction signalSetFn<T>(this: SignalFn<T>, newValue: T) {\n  const node = this[SIGNAL];\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\n\nfunction signalUpdateFn<T>(this: SignalFn<T>, updater: (value: T) => T): void {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n\n  signalSetFn.call(this as any, updater(this[SIGNAL].value) as any);\n}\n\nfunction signalMutateFn<T>(this: SignalFn<T>, mutator: (value: T) => void): void {\n  const node = this[SIGNAL];\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  // Mutate bypasses equality checks as it's by definition changing the value.\n  mutator(node.value);\n  signalValueChanged(node);\n}\n\nfunction signalAsReadonlyFn<T>(this: SignalFn<T>) {\n  const node = this[SIGNAL];\n  if (node.readonlyFn === undefined) {\n    const readonlyFn = () => this();\n    (readonlyFn as any)[SIGNAL] = node;\n    node.readonlyFn = readonlyFn as Signal<T>;\n  }\n  return node.readonlyFn;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {setActiveConsumer} from './graph';\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nexport function untracked<T>(nonReactiveReadsFn: () => T): T {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {consumerAfterComputation, consumerBeforeComputation, consumerMarkDirty, consumerPollProducersForChange, REACTIVE_NODE, ReactiveNode} from './graph';\n\n/**\n * A cleanup function that can be optionally registered from the watch logic. If registered, the\n * cleanup logic runs before the next watch execution.\n */\nexport type WatchCleanupFn = () => void;\n\n/**\n * A callback passed to the watch function that makes it possible to register cleanup logic.\n */\nexport type WatchCleanupRegisterFn = (cleanupFn: WatchCleanupFn) => void;\n\nexport interface Watch {\n  notify(): void;\n\n  /**\n   * Execute the reactive expression in the context of this `Watch` consumer.\n   *\n   * Should be called by the user scheduling algorithm when the provided\n   * `schedule` hook is called by `Watch`.\n   */\n  run(): void;\n  cleanup(): void;\n}\n\nexport function watch(\n    fn: (onCleanup: WatchCleanupRegisterFn) => void, schedule: (watch: Watch) => void,\n    allowSignalWrites: boolean): Watch {\n  const node: WatchNode = Object.create(WATCH_NODE);\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n\n  node.fn = fn;\n  node.schedule = schedule;\n\n  const registerOnCleanup = (cleanupFn: WatchCleanupFn) => {\n    node.cleanupFn = cleanupFn;\n  };\n\n  const run = () => {\n    node.dirty = false;\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n    node.hasRun = true;\n\n    const prevConsumer = consumerBeforeComputation(node);\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn(),\n  };\n\n  return node.ref;\n}\n\nconst NOOP_CLEANUP_FN: WatchCleanupFn = () => {};\n\ninterface WatchNode extends ReactiveNode {\n  hasRun: boolean;\n  fn: (onCleanup: WatchCleanupRegisterFn) => void;\n  schedule: (watch: Watch) => void;\n  cleanupFn: WatchCleanupFn;\n  ref: Watch;\n}\n\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE: Partial<WatchNode> = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: (node: WatchNode) => {\n      node.schedule(node.ref);\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN,\n  };\n})();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function setAlternateWeakRefImpl(impl: unknown) {\n  // TODO: remove this function\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInInjectionContext, computed, DestroyRef, inject, Injector, signal, Signal, WritableSignal} from '@angular/core';\nimport {Observable, Subscribable} from 'rxjs';\n\nimport {RuntimeError, RuntimeErrorCode} from '../../src/errors';\nimport {untracked} from '../../src/signals';\n\n/**\n * Options for `toSignal`.\n *\n * @publicApi\n */\nexport interface ToSignalOptions<T> {\n  /**\n   * Initial value for the signal produced by `toSignal`.\n   *\n   * This will be the value of the signal until the observable emits its first value.\n   */\n  initialValue?: T;\n\n  /**\n   * Whether to require that the observable emits synchronously when `toSignal` subscribes.\n   *\n   * If this is `true`, `toSignal` will assert that the observable produces a value immediately upon\n   * subscription. Setting this option removes the need to either deal with `undefined` in the\n   * signal type or provide an `initialValue`, at the cost of a runtime error if this requirement is\n   * not met.\n   */\n  requireSync?: boolean;\n\n  /**\n   * `Injector` which will provide the `DestroyRef` used to clean up the Observable subscription.\n   *\n   * If this is not provided, a `DestroyRef` will be retrieved from the current [injection\n   * context](/guide/dependency-injection-context), unless manual cleanup is requested.\n   */\n  injector?: Injector;\n\n  /**\n   * Whether the subscription should be automatically cleaned up (via `DestroyRef`) when\n   * `toObservable`'s creation context is destroyed.\n   *\n   * If manual cleanup is enabled, then `DestroyRef` is not used, and the subscription will persist\n   * until the `Observable` itself completes.\n   */\n  manualCleanup?: boolean;\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * Before the `Observable` emits its first value, the `Signal` will return `undefined`. To avoid\n * this, either an `initialValue` can be passed or the `requireSync` option enabled.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/dependency-injection-context) is destroyed. For example, when `toObservable` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an [injection context](/guide/dependency-injection-context) is not\n * available, an explicit `Injector` can be passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n */\nexport function toSignal<T>(source: Observable<T>|Subscribable<T>): Signal<T|undefined>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * Before the `Observable` emits its first value, the `Signal` will return the configured\n * `initialValue`, or `undefined` if no `initialValue` is provided. If the `Observable` is\n * guaranteed to emit synchronously, then the `requireSync` option can be passed instead.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toObservable` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T>(\n    source: Observable<T>|Subscribable<T>,\n    options?: ToSignalOptions<undefined>&{requireSync?: false}): Signal<T|undefined>;\n\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * Before the `Observable` emits its first value, the `Signal` will return the configured\n * `initialValue`. If the `Observable` is guaranteed to emit synchronously, then the `requireSync`\n * option can be passed instead.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/dependency-injection-context) is destroyed. For example, when `toObservable` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an [injection context](/guide/dependency-injection-context) is not\n * available, an explicit `Injector` can be passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T, U extends T|null|undefined>(\n    source: Observable<T>|Subscribable<T>,\n    options: ToSignalOptions<U>&{initialValue: U, requireSync?: false}): Signal<T|U>;\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toObservable` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nexport function toSignal<T>(\n    source: Observable<T>|Subscribable<T>,\n    options: ToSignalOptions<undefined>&{requireSync: true}): Signal<T>;\nexport function toSignal<T, U = undefined>(\n    source: Observable<T>|Subscribable<T>, options?: ToSignalOptions<U>): Signal<T|U> {\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef =\n      requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state: WritableSignal<State<T|U>>;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({kind: StateKind.NoValue});\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal<State<T|U>>({kind: StateKind.Value, value: options?.initialValue as U});\n  }\n\n  untracked(() => {\n    const sub = source.subscribe({\n      next: value => state.set({kind: StateKind.Value, value}),\n      error: error => state.set({kind: StateKind.Error, error}),\n      // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n      // \"complete\".\n    });\n\n    if (ngDevMode && options?.requireSync && state().kind === StateKind.NoValue) {\n      throw new RuntimeError(\n          RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n          '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  });\n\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case StateKind.Value:\n        return current.value;\n      case StateKind.Error:\n        throw current.error;\n      case StateKind.NoValue:\n        // This shouldn't really happen because the error is thrown on creation.\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new RuntimeError(\n            RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT,\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  });\n}\n\nconst enum StateKind {\n  NoValue,\n  Value,\n  Error,\n}\n\ninterface NoValueState {\n  kind: StateKind.NoValue;\n}\n\ninterface ValueState<T> {\n  kind: StateKind.Value;\n  value: T;\n}\n\ninterface ErrorState {\n  kind: StateKind.Error;\n  error: unknown;\n}\n\ntype State<T> = NoValueState|ValueState<T>|ErrorState;\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["untracked","global","signal","computed"],"mappings":"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"}